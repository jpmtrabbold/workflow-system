/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.8.2.0 (NJsonSchema v10.2.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { makeObservable, observable } from "mobx"

import * as moment from 'moment';

export interface IAuditClient {
    list(listRequest: AuditEntriesListRequest): Promise<AuditEntriesListResponse>;
}

export class AuditClient implements IAuditClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44384";
    }

    list(listRequest: AuditEntriesListRequest): Promise<AuditEntriesListResponse> {
        let url_ = this.baseUrl + "/api/Audit/List";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<AuditEntriesListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuditEntriesListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuditEntriesListResponse>(<any>null);
    }
}

export interface IConfigurationClient {
    list(listRequest: ConfigurationGroupsListRequest): Promise<ConfigurationGroupsListResponse>;
    get(id: number): Promise<ConfigurationGroupDto>;
    post(model: ConfigurationGroupDto): Promise<ConfigurationGroupPostResponse>;
}

export class ConfigurationClient implements IConfigurationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44384";
    }

    list(listRequest: ConfigurationGroupsListRequest): Promise<ConfigurationGroupsListResponse> {
        let url_ = this.baseUrl + "/api/Configuration/List";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<ConfigurationGroupsListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigurationGroupsListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConfigurationGroupsListResponse>(<any>null);
    }

    get(id: number): Promise<ConfigurationGroupDto> {
        let url_ = this.baseUrl + "/api/Configuration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ConfigurationGroupDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigurationGroupDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConfigurationGroupDto>(<any>null);
    }

    post(model: ConfigurationGroupDto): Promise<ConfigurationGroupPostResponse> {
        let url_ = this.baseUrl + "/api/Configuration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<ConfigurationGroupPostResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigurationGroupPostResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConfigurationGroupPostResponse>(<any>null);
    }
}

export interface ICounterpartyClient {
    list(listRequest: CounterpartiesListRequest): Promise<CounterpartiesListResponse>;
    get(id: number): Promise<CounterpartyDto>;
    post(counterparty: CounterpartyDto): Promise<CounterpartyPostResponse>;
    checkCodeUsedInDeals(counterpartyId?: number | undefined): Promise<boolean>;
    checkForDuplicateCodes(counterpartyId?: number | undefined, code?: string | undefined): Promise<boolean>;
    getCountries(): Promise<LookupRequest[]>;
}

export class CounterpartyClient implements ICounterpartyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44384";
    }

    list(listRequest: CounterpartiesListRequest): Promise<CounterpartiesListResponse> {
        let url_ = this.baseUrl + "/api/Counterparty/List";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<CounterpartiesListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CounterpartiesListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CounterpartiesListResponse>(<any>null);
    }

    get(id: number): Promise<CounterpartyDto> {
        let url_ = this.baseUrl + "/api/Counterparty/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<CounterpartyDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CounterpartyDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CounterpartyDto>(<any>null);
    }

    post(counterparty: CounterpartyDto): Promise<CounterpartyPostResponse> {
        let url_ = this.baseUrl + "/api/Counterparty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(counterparty);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<CounterpartyPostResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CounterpartyPostResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CounterpartyPostResponse>(<any>null);
    }

    checkCodeUsedInDeals(counterpartyId?: number | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Counterparty/CheckCodeUsedInDeals?";
        if (counterpartyId === null)
            throw new Error("The parameter 'counterpartyId' cannot be null.");
        else if (counterpartyId !== undefined)
            url_ += "counterpartyId=" + encodeURIComponent("" + counterpartyId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckCodeUsedInDeals(_response);
        });
    }

    protected processCheckCodeUsedInDeals(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    checkForDuplicateCodes(counterpartyId?: number | undefined, code?: string | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Counterparty/CheckForDuplicateCodes?";
        if (counterpartyId === null)
            throw new Error("The parameter 'counterpartyId' cannot be null.");
        else if (counterpartyId !== undefined)
            url_ += "counterpartyId=" + encodeURIComponent("" + counterpartyId) + "&"; 
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckForDuplicateCodes(_response);
        });
    }

    protected processCheckForDuplicateCodes(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    getCountries(): Promise<LookupRequest[]> {
        let url_ = this.baseUrl + "/api/Counterparty/GetCountries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCountries(_response);
        });
    }

    protected processGetCountries(response: Response): Promise<LookupRequest[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupRequest.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LookupRequest[]>(<any>null);
    }
}

export interface IDealCategoryClient {
    list(listRequest: DealCategoriesListRequest): Promise<DealCategoriesListResponse>;
    get(id: number): Promise<DealCategoryDto>;
    post(dealCategory: DealCategoryDto): Promise<DealCategoryPostResponse>;
}

export class DealCategoryClient implements IDealCategoryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44384";
    }

    list(listRequest: DealCategoriesListRequest): Promise<DealCategoriesListResponse> {
        let url_ = this.baseUrl + "/api/DealCategory/List";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<DealCategoriesListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DealCategoriesListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealCategoriesListResponse>(<any>null);
    }

    get(id: number): Promise<DealCategoryDto> {
        let url_ = this.baseUrl + "/api/DealCategory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<DealCategoryDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DealCategoryDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealCategoryDto>(<any>null);
    }

    post(dealCategory: DealCategoryDto): Promise<DealCategoryPostResponse> {
        let url_ = this.baseUrl + "/api/DealCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dealCategory);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<DealCategoryPostResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DealCategoryPostResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealCategoryPostResponse>(<any>null);
    }
}

export interface IDealClient {
    list(listRequest: DealsListRequest): Promise<DealsListResponse>;
    get(id: number, light?: boolean | undefined): Promise<DealDto>;
    getItems(id: number): Promise<DealItemDto[]>;
    getNotes(id: number): Promise<DealNoteDto[]>;
    getAttachments(id: number): Promise<DealAttachmentDto[]>;
    post(deal: DealDto): Promise<DealPostResponse>;
    dealAssignInfo(dealId?: number | undefined): Promise<DealAssignInfoResponse>;
    assignDealToSelf(dealId?: number | undefined, currentAssignedToUserId?: number | null | undefined): Promise<void>;
    revertDealStatusBack(dealId?: number | undefined, workflowStatusId?: number | undefined, currentDealworkflowStatusId?: number | null | undefined, currentAssignedToUserId?: number | null | undefined): Promise<void>;
    dealExecutionInfo(dealId?: number | undefined): Promise<DealExecutionInfoResponse>;
    assignDealExecutionToSelf(dealId?: number | undefined, currentExecutionUserId?: number | null | undefined, currentExecutionDate?: moment.Moment | null | undefined): Promise<void>;
    reverseDealExecution(dealId?: number | undefined, currentExecutionUserId?: number | null | undefined, currentExecutionDate?: moment.Moment | null | undefined): Promise<void>;
    getDealCategories(): Promise<LookupRequest[]>;
    getDealTypes(dealCategoryId?: number | undefined): Promise<LookupRequest[]>;
    getCounterparties(listRequest: CounterpartiesListRequest): Promise<LookupRequestHeader>;
    getProducts(dealCategoryId?: number | undefined): Promise<LookupRequest[]>;
    getDealTypeConfiguration(dealTypeId?: number | undefined, itemFieldsetId?: number | null | undefined, workflowSetId?: number | null | undefined, currentWorkflowStatusId?: number | null | undefined): Promise<DealTypeConfigurationResponse>;
    getAttachmentTypes(): Promise<AttachmentTypeLookupRequest[]>;
    downloadAttachmentVersion(attachmentVersionId?: number | undefined): Promise<FileResponse | null>;
    getTradePolicyEvaluation(dealId?: number | undefined, userId?: number | undefined): Promise<DealWorkflowAssignmentDto[]>;
}

export class DealClient implements IDealClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44384";
    }

    list(listRequest: DealsListRequest): Promise<DealsListResponse> {
        let url_ = this.baseUrl + "/api/Deal/List";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<DealsListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DealsListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealsListResponse>(<any>null);
    }

    get(id: number, light?: boolean | undefined): Promise<DealDto> {
        let url_ = this.baseUrl + "/api/Deal/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (light === null)
            throw new Error("The parameter 'light' cannot be null.");
        else if (light !== undefined)
            url_ += "light=" + encodeURIComponent("" + light) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<DealDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DealDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealDto>(<any>null);
    }

    getItems(id: number): Promise<DealItemDto[]> {
        let url_ = this.baseUrl + "/api/Deal/GetItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetItems(_response);
        });
    }

    protected processGetItems(response: Response): Promise<DealItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DealItemDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealItemDto[]>(<any>null);
    }

    getNotes(id: number): Promise<DealNoteDto[]> {
        let url_ = this.baseUrl + "/api/Deal/GetNotes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNotes(_response);
        });
    }

    protected processGetNotes(response: Response): Promise<DealNoteDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DealNoteDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealNoteDto[]>(<any>null);
    }

    getAttachments(id: number): Promise<DealAttachmentDto[]> {
        let url_ = this.baseUrl + "/api/Deal/GetAttachments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAttachments(_response);
        });
    }

    protected processGetAttachments(response: Response): Promise<DealAttachmentDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DealAttachmentDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealAttachmentDto[]>(<any>null);
    }

    post(deal: DealDto): Promise<DealPostResponse> {
        let url_ = this.baseUrl + "/api/Deal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deal);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<DealPostResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DealPostResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealPostResponse>(<any>null);
    }

    dealAssignInfo(dealId?: number | undefined): Promise<DealAssignInfoResponse> {
        let url_ = this.baseUrl + "/api/Deal/DealAssignInfo?";
        if (dealId === null)
            throw new Error("The parameter 'dealId' cannot be null.");
        else if (dealId !== undefined)
            url_ += "dealId=" + encodeURIComponent("" + dealId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDealAssignInfo(_response);
        });
    }

    protected processDealAssignInfo(response: Response): Promise<DealAssignInfoResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DealAssignInfoResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealAssignInfoResponse>(<any>null);
    }

    assignDealToSelf(dealId?: number | undefined, currentAssignedToUserId?: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Deal/AssignDealToSelf?";
        if (dealId === null)
            throw new Error("The parameter 'dealId' cannot be null.");
        else if (dealId !== undefined)
            url_ += "dealId=" + encodeURIComponent("" + dealId) + "&"; 
        if (currentAssignedToUserId !== undefined)
            url_ += "currentAssignedToUserId=" + encodeURIComponent("" + currentAssignedToUserId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssignDealToSelf(_response);
        });
    }

    protected processAssignDealToSelf(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    revertDealStatusBack(dealId?: number | undefined, workflowStatusId?: number | undefined, currentDealworkflowStatusId?: number | null | undefined, currentAssignedToUserId?: number | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Deal/RevertDealStatusBack?";
        if (dealId === null)
            throw new Error("The parameter 'dealId' cannot be null.");
        else if (dealId !== undefined)
            url_ += "dealId=" + encodeURIComponent("" + dealId) + "&"; 
        if (workflowStatusId === null)
            throw new Error("The parameter 'workflowStatusId' cannot be null.");
        else if (workflowStatusId !== undefined)
            url_ += "workflowStatusId=" + encodeURIComponent("" + workflowStatusId) + "&"; 
        if (currentDealworkflowStatusId !== undefined)
            url_ += "currentDealworkflowStatusId=" + encodeURIComponent("" + currentDealworkflowStatusId) + "&"; 
        if (currentAssignedToUserId !== undefined)
            url_ += "currentAssignedToUserId=" + encodeURIComponent("" + currentAssignedToUserId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRevertDealStatusBack(_response);
        });
    }

    protected processRevertDealStatusBack(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    dealExecutionInfo(dealId?: number | undefined): Promise<DealExecutionInfoResponse> {
        let url_ = this.baseUrl + "/api/Deal/DealExecutionInfo?";
        if (dealId === null)
            throw new Error("The parameter 'dealId' cannot be null.");
        else if (dealId !== undefined)
            url_ += "dealId=" + encodeURIComponent("" + dealId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDealExecutionInfo(_response);
        });
    }

    protected processDealExecutionInfo(response: Response): Promise<DealExecutionInfoResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DealExecutionInfoResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealExecutionInfoResponse>(<any>null);
    }

    assignDealExecutionToSelf(dealId?: number | undefined, currentExecutionUserId?: number | null | undefined, currentExecutionDate?: moment.Moment | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Deal/AssignDealExecutionToSelf?";
        if (dealId === null)
            throw new Error("The parameter 'dealId' cannot be null.");
        else if (dealId !== undefined)
            url_ += "dealId=" + encodeURIComponent("" + dealId) + "&"; 
        if (currentExecutionUserId !== undefined)
            url_ += "currentExecutionUserId=" + encodeURIComponent("" + currentExecutionUserId) + "&"; 
        if (currentExecutionDate !== undefined)
            url_ += "currentExecutionDate=" + encodeURIComponent(currentExecutionDate ? "" + currentExecutionDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssignDealExecutionToSelf(_response);
        });
    }

    protected processAssignDealExecutionToSelf(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    reverseDealExecution(dealId?: number | undefined, currentExecutionUserId?: number | null | undefined, currentExecutionDate?: moment.Moment | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Deal/ReverseDealExecution?";
        if (dealId === null)
            throw new Error("The parameter 'dealId' cannot be null.");
        else if (dealId !== undefined)
            url_ += "dealId=" + encodeURIComponent("" + dealId) + "&"; 
        if (currentExecutionUserId !== undefined)
            url_ += "currentExecutionUserId=" + encodeURIComponent("" + currentExecutionUserId) + "&"; 
        if (currentExecutionDate !== undefined)
            url_ += "currentExecutionDate=" + encodeURIComponent(currentExecutionDate ? "" + currentExecutionDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReverseDealExecution(_response);
        });
    }

    protected processReverseDealExecution(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    getDealCategories(): Promise<LookupRequest[]> {
        let url_ = this.baseUrl + "/api/Deal/GetDealCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDealCategories(_response);
        });
    }

    protected processGetDealCategories(response: Response): Promise<LookupRequest[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupRequest.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LookupRequest[]>(<any>null);
    }

    getDealTypes(dealCategoryId?: number | undefined): Promise<LookupRequest[]> {
        let url_ = this.baseUrl + "/api/Deal/GetDealTypes?";
        if (dealCategoryId === null)
            throw new Error("The parameter 'dealCategoryId' cannot be null.");
        else if (dealCategoryId !== undefined)
            url_ += "dealCategoryId=" + encodeURIComponent("" + dealCategoryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDealTypes(_response);
        });
    }

    protected processGetDealTypes(response: Response): Promise<LookupRequest[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupRequest.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LookupRequest[]>(<any>null);
    }

    getCounterparties(listRequest: CounterpartiesListRequest): Promise<LookupRequestHeader> {
        let url_ = this.baseUrl + "/api/Deal/GetCounterparties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCounterparties(_response);
        });
    }

    protected processGetCounterparties(response: Response): Promise<LookupRequestHeader> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LookupRequestHeader.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LookupRequestHeader>(<any>null);
    }

    getProducts(dealCategoryId?: number | undefined): Promise<LookupRequest[]> {
        let url_ = this.baseUrl + "/api/Deal/GetNodes?";
        if (dealCategoryId === null)
            throw new Error("The parameter 'dealCategoryId' cannot be null.");
        else if (dealCategoryId !== undefined)
            url_ += "dealCategoryId=" + encodeURIComponent("" + dealCategoryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProducts(_response);
        });
    }

    protected processGetProducts(response: Response): Promise<LookupRequest[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupRequest.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LookupRequest[]>(<any>null);
    }

    getDealTypeConfiguration(dealTypeId?: number | undefined, itemFieldsetId?: number | null | undefined, workflowSetId?: number | null | undefined, currentWorkflowStatusId?: number | null | undefined): Promise<DealTypeConfigurationResponse> {
        let url_ = this.baseUrl + "/api/Deal/GetDealTypeConfiguration?";
        if (dealTypeId === null)
            throw new Error("The parameter 'dealTypeId' cannot be null.");
        else if (dealTypeId !== undefined)
            url_ += "dealTypeId=" + encodeURIComponent("" + dealTypeId) + "&"; 
        if (itemFieldsetId !== undefined)
            url_ += "itemFieldsetId=" + encodeURIComponent("" + itemFieldsetId) + "&"; 
        if (workflowSetId !== undefined)
            url_ += "workflowSetId=" + encodeURIComponent("" + workflowSetId) + "&"; 
        if (currentWorkflowStatusId !== undefined)
            url_ += "currentWorkflowStatusId=" + encodeURIComponent("" + currentWorkflowStatusId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDealTypeConfiguration(_response);
        });
    }

    protected processGetDealTypeConfiguration(response: Response): Promise<DealTypeConfigurationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DealTypeConfigurationResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealTypeConfigurationResponse>(<any>null);
    }

    getAttachmentTypes(): Promise<AttachmentTypeLookupRequest[]> {
        let url_ = this.baseUrl + "/api/Deal/GetAttachmentTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAttachmentTypes(_response);
        });
    }

    protected processGetAttachmentTypes(response: Response): Promise<AttachmentTypeLookupRequest[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttachmentTypeLookupRequest.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AttachmentTypeLookupRequest[]>(<any>null);
    }

    downloadAttachmentVersion(attachmentVersionId?: number | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Deal/DownloadAttachmentVersion?";
        if (attachmentVersionId === null)
            throw new Error("The parameter 'attachmentVersionId' cannot be null.");
        else if (attachmentVersionId !== undefined)
            url_ += "attachmentVersionId=" + encodeURIComponent("" + attachmentVersionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownloadAttachmentVersion(_response);
        });
    }

    protected processDownloadAttachmentVersion(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    getTradePolicyEvaluation(dealId?: number | undefined, userId?: number | undefined): Promise<DealWorkflowAssignmentDto[]> {
        let url_ = this.baseUrl + "/api/Deal/GetTradePolicyEvaluation?";
        if (dealId === null)
            throw new Error("The parameter 'dealId' cannot be null.");
        else if (dealId !== undefined)
            url_ += "dealId=" + encodeURIComponent("" + dealId) + "&"; 
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTradePolicyEvaluation(_response);
        });
    }

    protected processGetTradePolicyEvaluation(response: Response): Promise<DealWorkflowAssignmentDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DealWorkflowAssignmentDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealWorkflowAssignmentDto[]>(<any>null);
    }
}

export interface IDealIntegrationClient {
    emsFetch(request: EmsFetchRequest): Promise<boolean>;
}

export class DealIntegrationClient implements IDealIntegrationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44384";
    }

    emsFetch(request: EmsFetchRequest): Promise<boolean> {
        let url_ = this.baseUrl + "/api/DealIntegration/EmsFetch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEmsFetch(_response);
        });
    }

    protected processEmsFetch(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export interface IDealItemFieldsetClient {
    list(listRequest: DealItemFieldsetsListRequest): Promise<DealItemFieldsetsListResponse>;
    get(id: number): Promise<DealItemFieldsetDto>;
    getItemFieldLookups(): Promise<StringLookupRequest[]>;
    post(itemFieldset: DealItemFieldsetDto): Promise<DealItemFieldsetPostResponse>;
}

export class DealItemFieldsetClient implements IDealItemFieldsetClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44384";
    }

    list(listRequest: DealItemFieldsetsListRequest): Promise<DealItemFieldsetsListResponse> {
        let url_ = this.baseUrl + "/api/DealItemFieldset/List";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<DealItemFieldsetsListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DealItemFieldsetsListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealItemFieldsetsListResponse>(<any>null);
    }

    get(id: number): Promise<DealItemFieldsetDto> {
        let url_ = this.baseUrl + "/api/DealItemFieldset/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<DealItemFieldsetDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DealItemFieldsetDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealItemFieldsetDto>(<any>null);
    }

    getItemFieldLookups(): Promise<StringLookupRequest[]> {
        let url_ = this.baseUrl + "/api/DealItemFieldset/GetItemFieldLookups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetItemFieldLookups(_response);
        });
    }

    protected processGetItemFieldLookups(response: Response): Promise<StringLookupRequest[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StringLookupRequest.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringLookupRequest[]>(<any>null);
    }

    post(itemFieldset: DealItemFieldsetDto): Promise<DealItemFieldsetPostResponse> {
        let url_ = this.baseUrl + "/api/DealItemFieldset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(itemFieldset);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<DealItemFieldsetPostResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DealItemFieldsetPostResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealItemFieldsetPostResponse>(<any>null);
    }
}

export interface IDealTypeClient {
    list(listRequest: DealTypesListRequest): Promise<DealTypesListResponse>;
    getWorkflowSetLookups(id?: number | undefined): Promise<LookupRequest[]>;
    getDealItemFieldsetLookups(id?: number | undefined): Promise<LookupRequest[]>;
    get(id: number): Promise<DealTypeDto>;
    post(dealType: DealTypeDto): Promise<DealTypePostResponse>;
}

export class DealTypeClient implements IDealTypeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44384";
    }

    list(listRequest: DealTypesListRequest): Promise<DealTypesListResponse> {
        let url_ = this.baseUrl + "/api/DealType/List";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<DealTypesListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DealTypesListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealTypesListResponse>(<any>null);
    }

    getWorkflowSetLookups(id?: number | undefined): Promise<LookupRequest[]> {
        let url_ = this.baseUrl + "/api/DealType/GetWorkflowSetLookups?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkflowSetLookups(_response);
        });
    }

    protected processGetWorkflowSetLookups(response: Response): Promise<LookupRequest[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupRequest.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LookupRequest[]>(<any>null);
    }

    getDealItemFieldsetLookups(id?: number | undefined): Promise<LookupRequest[]> {
        let url_ = this.baseUrl + "/api/DealType/GetDealItemFieldsetLookups?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDealItemFieldsetLookups(_response);
        });
    }

    protected processGetDealItemFieldsetLookups(response: Response): Promise<LookupRequest[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupRequest.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LookupRequest[]>(<any>null);
    }

    get(id: number): Promise<DealTypeDto> {
        let url_ = this.baseUrl + "/api/DealType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<DealTypeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DealTypeDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealTypeDto>(<any>null);
    }

    post(dealType: DealTypeDto): Promise<DealTypePostResponse> {
        let url_ = this.baseUrl + "/api/DealType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dealType);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<DealTypePostResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DealTypePostResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealTypePostResponse>(<any>null);
    }
}

export interface IIntegrationClient {
    list(listRequest: IntegrationRunsListRequest): Promise<IntegrationRunsListResponse>;
    getEntries(integrationRunId?: number | undefined): Promise<IntegrationRunEntryDto[]>;
    changeIntegrationRunStatus(integrationRunId?: number | undefined, currentStatus?: IntegrationRunStatusEnum | undefined, newStatus?: IntegrationRunStatusEnum | undefined): Promise<void>;
}

export class IntegrationClient implements IIntegrationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44384";
    }

    list(listRequest: IntegrationRunsListRequest): Promise<IntegrationRunsListResponse> {
        let url_ = this.baseUrl + "/api/Integration/List";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<IntegrationRunsListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IntegrationRunsListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IntegrationRunsListResponse>(<any>null);
    }

    getEntries(integrationRunId?: number | undefined): Promise<IntegrationRunEntryDto[]> {
        let url_ = this.baseUrl + "/api/Integration/GetEntries?";
        if (integrationRunId === null)
            throw new Error("The parameter 'integrationRunId' cannot be null.");
        else if (integrationRunId !== undefined)
            url_ += "integrationRunId=" + encodeURIComponent("" + integrationRunId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntries(_response);
        });
    }

    protected processGetEntries(response: Response): Promise<IntegrationRunEntryDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IntegrationRunEntryDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IntegrationRunEntryDto[]>(<any>null);
    }

    changeIntegrationRunStatus(integrationRunId?: number | undefined, currentStatus?: IntegrationRunStatusEnum | undefined, newStatus?: IntegrationRunStatusEnum | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Integration/ChangeIntegrationRunStatus?";
        if (integrationRunId === null)
            throw new Error("The parameter 'integrationRunId' cannot be null.");
        else if (integrationRunId !== undefined)
            url_ += "integrationRunId=" + encodeURIComponent("" + integrationRunId) + "&"; 
        if (currentStatus === null)
            throw new Error("The parameter 'currentStatus' cannot be null.");
        else if (currentStatus !== undefined)
            url_ += "currentStatus=" + encodeURIComponent("" + currentStatus) + "&"; 
        if (newStatus === null)
            throw new Error("The parameter 'newStatus' cannot be null.");
        else if (newStatus !== undefined)
            url_ += "newStatus=" + encodeURIComponent("" + newStatus) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeIntegrationRunStatus(_response);
        });
    }

    protected processChangeIntegrationRunStatus(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export interface ILoginClient {
    hangfireLogin(): Promise<FileResponse | null>;
    signOut(): Promise<FileResponse | null>;
    signedOut(): Promise<string>;
    healthCheck(): Promise<string>;
}

export class LoginClient implements ILoginClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44384";
    }

    hangfireLogin(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Login/HangfireLogin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHangfireLogin(_response);
        });
    }

    protected processHangfireLogin(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    signOut(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Login/SignOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignOut(_response);
        });
    }

    protected processSignOut(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    signedOut(): Promise<string> {
        let url_ = this.baseUrl + "/api/Login";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignedOut(_response);
        });
    }

    protected processSignedOut(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    healthCheck(): Promise<string> {
        let url_ = this.baseUrl + "/api/Login/HealthCheck";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHealthCheck(_response);
        });
    }

    protected processHealthCheck(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }
}

export interface IProductClient {
    list(listRequest: ProductsListRequest): Promise<ProductsListResponse>;
    get(id: number): Promise<ProductDto>;
    post(node: ProductDto): Promise<ProductPostResponse>;
    getProducts(node: ProductDto, dealCategoryId?: number | undefined, query?: string | undefined): Promise<LookupRequest[]>;
}

export class ProductClient implements IProductClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44384";
    }

    list(listRequest: ProductsListRequest): Promise<ProductsListResponse> {
        let url_ = this.baseUrl + "/api/Product/List";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<ProductsListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductsListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductsListResponse>(<any>null);
    }

    get(id: number): Promise<ProductDto> {
        let url_ = this.baseUrl + "/api/Product/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ProductDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductDto>(<any>null);
    }

    post(node: ProductDto): Promise<ProductPostResponse> {
        let url_ = this.baseUrl + "/api/Product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(node);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<ProductPostResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductPostResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductPostResponse>(<any>null);
    }

    getProducts(node: ProductDto, dealCategoryId?: number | undefined, query?: string | undefined): Promise<LookupRequest[]> {
        let url_ = this.baseUrl + "/api/Product/GetProducts?";
        if (dealCategoryId === null)
            throw new Error("The parameter 'dealCategoryId' cannot be null.");
        else if (dealCategoryId !== undefined)
            url_ += "dealCategoryId=" + encodeURIComponent("" + dealCategoryId) + "&"; 
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(node);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProducts(_response);
        });
    }

    protected processGetProducts(response: Response): Promise<LookupRequest[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupRequest.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LookupRequest[]>(<any>null);
    }
}

export interface IPublicClient {
    dealDirectWorkflowAction(request: DealDirectWorkflowActionRequest): Promise<DealDirectWorkflowActionResponse>;
}

export class PublicClient implements IPublicClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44384";
    }

    dealDirectWorkflowAction(request: DealDirectWorkflowActionRequest): Promise<DealDirectWorkflowActionResponse> {
        let url_ = this.baseUrl + "/api/Public/DealDirectWorkflowAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDealDirectWorkflowAction(_response);
        });
    }

    protected processDealDirectWorkflowAction(response: Response): Promise<DealDirectWorkflowActionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DealDirectWorkflowActionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealDirectWorkflowActionResponse>(<any>null);
    }
}

export interface ISalesForecastClient {
    list(listRequest: SalesForecastsListRequest): Promise<SalesForecastsListResponse>;
    get(id: number): Promise<SalesForecastDto>;
    post(dealCategory: SalesForecastDto): Promise<SalesForecastPostResponse>;
    bulkImport(list: SalesForecastDto[]): Promise<void>;
}

export class SalesForecastClient implements ISalesForecastClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44384";
    }

    list(listRequest: SalesForecastsListRequest): Promise<SalesForecastsListResponse> {
        let url_ = this.baseUrl + "/api/SalesForecast/List";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<SalesForecastsListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalesForecastsListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SalesForecastsListResponse>(<any>null);
    }

    get(id: number): Promise<SalesForecastDto> {
        let url_ = this.baseUrl + "/api/SalesForecast/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<SalesForecastDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalesForecastDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SalesForecastDto>(<any>null);
    }

    post(dealCategory: SalesForecastDto): Promise<SalesForecastPostResponse> {
        let url_ = this.baseUrl + "/api/SalesForecast";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dealCategory);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<SalesForecastPostResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalesForecastPostResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SalesForecastPostResponse>(<any>null);
    }

    bulkImport(list: SalesForecastDto[]): Promise<void> {
        let url_ = this.baseUrl + "/api/SalesForecast/BulkImport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(list);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkImport(_response);
        });
    }

    protected processBulkImport(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export interface ISharedClient {
    enumsDefinitions(): Promise<EnumsDefinitionsRequest>;
}

export class SharedClient implements ISharedClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44384";
    }

    enumsDefinitions(): Promise<EnumsDefinitionsRequest> {
        let url_ = this.baseUrl + "/api/Shared/EnumsDefinitions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnumsDefinitions(_response);
        });
    }

    protected processEnumsDefinitions(response: Response): Promise<EnumsDefinitionsRequest> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EnumsDefinitionsRequest.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EnumsDefinitionsRequest>(<any>null);
    }
}

export interface IUserClient {
    list(listRequest: UsersListRequest): Promise<UsersListResponse>;
    get(id: number): Promise<UserDto>;
    post(user: UserDto): Promise<UserPostResponse>;
    getWorkflowRoles(): Promise<LookupRequest[]>;
    getUserRoles(): Promise<LookupRequest[]>;
    listFunctionalities(): Promise<UserFunctionalityReadDto[]>;
    getWorkflowRolesForCurrentUser(): Promise<LookupRequest[]>;
    getWorkflowRolesForUsersAndCurrent(userIds: number[]): Promise<LookupRequestHeader[]>;
}

export class UserClient implements IUserClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44384";
    }

    list(listRequest: UsersListRequest): Promise<UsersListResponse> {
        let url_ = this.baseUrl + "/api/User/List";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listRequest);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<UsersListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UsersListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UsersListResponse>(<any>null);
    }

    get(id: number): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto>(<any>null);
    }

    post(user: UserDto): Promise<UserPostResponse> {
        let url_ = this.baseUrl + "/api/User";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<UserPostResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserPostResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserPostResponse>(<any>null);
    }

    getWorkflowRoles(): Promise<LookupRequest[]> {
        let url_ = this.baseUrl + "/api/User/GetWorkflowRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkflowRoles(_response);
        });
    }

    protected processGetWorkflowRoles(response: Response): Promise<LookupRequest[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupRequest.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LookupRequest[]>(<any>null);
    }

    getUserRoles(): Promise<LookupRequest[]> {
        let url_ = this.baseUrl + "/api/User/GetUserRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserRoles(_response);
        });
    }

    protected processGetUserRoles(response: Response): Promise<LookupRequest[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupRequest.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LookupRequest[]>(<any>null);
    }

    listFunctionalities(): Promise<UserFunctionalityReadDto[]> {
        let url_ = this.baseUrl + "/api/User/ListFunctionalities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListFunctionalities(_response);
        });
    }

    protected processListFunctionalities(response: Response): Promise<UserFunctionalityReadDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserFunctionalityReadDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserFunctionalityReadDto[]>(<any>null);
    }

    getWorkflowRolesForCurrentUser(): Promise<LookupRequest[]> {
        let url_ = this.baseUrl + "/api/User/GetWorkflowRolesForCurrentUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkflowRolesForCurrentUser(_response);
        });
    }

    protected processGetWorkflowRolesForCurrentUser(response: Response): Promise<LookupRequest[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupRequest.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LookupRequest[]>(<any>null);
    }

    getWorkflowRolesForUsersAndCurrent(userIds: number[]): Promise<LookupRequestHeader[]> {
        let url_ = this.baseUrl + "/api/User/GetWorkflowRolesForUsersAndCurrent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userIds);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkflowRolesForUsersAndCurrent(_response);
        });
    }

    protected processGetWorkflowRolesForUsersAndCurrent(response: Response): Promise<LookupRequestHeader[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LookupRequestHeader.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LookupRequestHeader[]>(<any>null);
    }
}

export class ListResponse implements IListResponse {
    totalRecords?: number | undefined;

    constructor(data?: IListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            totalRecords: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.totalRecords = _data["totalRecords"];
        }
    }

    static fromJS(data: any): ListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRecords"] = this.totalRecords;
        return data; 
    }

    clone(): ListResponse {
        const json = this.toJSON();
        let result = new ListResponse();
        result.init(json);
        return result;
    }
}

export interface IListResponse {
    totalRecords?: number | undefined;
}

export class AuditEntriesListResponse extends ListResponse implements IAuditEntriesListResponse {
    auditEntries!: AuditEntryListDto[];

    constructor(data?: IAuditEntriesListResponse) {
        super(data);
        if (data) {
            if (data.auditEntries) {
                this.auditEntries = [];
                for (let i = 0; i < data.auditEntries.length; i++) {
                    let item = data.auditEntries[i];
                    this.auditEntries[i] = item && !(<any>item).toJSON ? new AuditEntryListDto(item) : <AuditEntryListDto>item;
                }
            }
        }
        if (!data) {
            this.auditEntries = [];
        }
        makeObservable(this, {
            auditEntries: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["auditEntries"])) {
                this.auditEntries = [] as any;
                for (let item of _data["auditEntries"])
                    this.auditEntries!.push(AuditEntryListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuditEntriesListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuditEntriesListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.auditEntries)) {
            data["auditEntries"] = [];
            for (let item of this.auditEntries)
                data["auditEntries"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): AuditEntriesListResponse {
        const json = this.toJSON();
        let result = new AuditEntriesListResponse();
        result.init(json);
        return result;
    }
}

export interface IAuditEntriesListResponse extends IListResponse {
    auditEntries: IAuditEntryListDto[];
}

export class AuditEntryListDto implements IAuditEntryListDto {
    id!: number;
    dateTime!: moment.Moment;
    userName!: string;
    tables!: AuditEntryTableListDto[];
    type!: AuditEntryTypeEnum;

    constructor(data?: IAuditEntryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.tables) {
                this.tables = [];
                for (let i = 0; i < data.tables.length; i++) {
                    let item = data.tables[i];
                    this.tables[i] = item && !(<any>item).toJSON ? new AuditEntryTableListDto(item) : <AuditEntryTableListDto>item;
                }
            }
        }
        if (!data) {
            this.tables = [];
        }
        makeObservable(this, {
            id: observable,
            dateTime: observable,
            userName: observable,
            tables: observable,
            type: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dateTime = _data["dateTime"] ? moment.parseZone(_data["dateTime"].toString()) : <any>undefined;
            this.userName = _data["userName"];
            if (Array.isArray(_data["tables"])) {
                this.tables = [] as any;
                for (let item of _data["tables"])
                    this.tables!.push(AuditEntryTableListDto.fromJS(item));
            }
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): AuditEntryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditEntryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString(true) : <any>undefined;
        data["userName"] = this.userName;
        if (Array.isArray(this.tables)) {
            data["tables"] = [];
            for (let item of this.tables)
                data["tables"].push(item.toJSON());
        }
        data["type"] = this.type;
        return data; 
    }

    clone(): AuditEntryListDto {
        const json = this.toJSON();
        let result = new AuditEntryListDto();
        result.init(json);
        return result;
    }
}

export interface IAuditEntryListDto {
    id: number;
    dateTime: moment.Moment;
    userName: string;
    tables: IAuditEntryTableListDto[];
    type: AuditEntryTypeEnum;
}

export class AuditEntryTableListDto implements IAuditEntryTableListDto {
    tableName!: string;
    action!: string;
    keyValues!: string;
    fields!: AuditEntryFieldListDto[];

    constructor(data?: IAuditEntryTableListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.fields) {
                this.fields = [];
                for (let i = 0; i < data.fields.length; i++) {
                    let item = data.fields[i];
                    this.fields[i] = item && !(<any>item).toJSON ? new AuditEntryFieldListDto(item) : <AuditEntryFieldListDto>item;
                }
            }
        }
        if (!data) {
            this.fields = [];
        }
        makeObservable(this, {
            tableName: observable,
            action: observable,
            keyValues: observable,
            fields: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.tableName = _data["tableName"];
            this.action = _data["action"];
            this.keyValues = _data["keyValues"];
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(AuditEntryFieldListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuditEntryTableListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditEntryTableListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tableName"] = this.tableName;
        data["action"] = this.action;
        data["keyValues"] = this.keyValues;
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AuditEntryTableListDto {
        const json = this.toJSON();
        let result = new AuditEntryTableListDto();
        result.init(json);
        return result;
    }
}

export interface IAuditEntryTableListDto {
    tableName: string;
    action: string;
    keyValues: string;
    fields: IAuditEntryFieldListDto[];
}

export class AuditEntryFieldListDto implements IAuditEntryFieldListDto {
    fieldName!: string;
    oldValue!: string;
    newValue!: string;

    constructor(data?: IAuditEntryFieldListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            fieldName: observable,
            oldValue: observable,
            newValue: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.oldValue = _data["oldValue"];
            this.newValue = _data["newValue"];
        }
    }

    static fromJS(data: any): AuditEntryFieldListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditEntryFieldListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["oldValue"] = this.oldValue;
        data["newValue"] = this.newValue;
        return data; 
    }

    clone(): AuditEntryFieldListDto {
        const json = this.toJSON();
        let result = new AuditEntryFieldListDto();
        result.init(json);
        return result;
    }
}

export interface IAuditEntryFieldListDto {
    fieldName: string;
    oldValue: string;
    newValue: string;
}

export enum AuditEntryTypeEnum {
    Added = 1,
    Modified = 2,
}

export class ListRequest implements IListRequest {
    id?: number | undefined;
    pageSize?: number | undefined;
    pageNumber?: number | undefined;
    sortField!: string;
    sortOrderAscending!: boolean;
    searchString!: string;
    onlyActive!: boolean;

    constructor(data?: IListRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            id: observable,
            pageSize: observable,
            pageNumber: observable,
            sortField: observable,
            sortOrderAscending: observable,
            searchString: observable,
            onlyActive: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.pageSize = _data["pageSize"];
            this.pageNumber = _data["pageNumber"];
            this.sortField = _data["sortField"];
            this.sortOrderAscending = _data["sortOrderAscending"];
            this.searchString = _data["searchString"];
            this.onlyActive = _data["onlyActive"];
        }
    }

    static fromJS(data: any): ListRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["pageSize"] = this.pageSize;
        data["pageNumber"] = this.pageNumber;
        data["sortField"] = this.sortField;
        data["sortOrderAscending"] = this.sortOrderAscending;
        data["searchString"] = this.searchString;
        data["onlyActive"] = this.onlyActive;
        return data; 
    }

    clone(): ListRequest {
        const json = this.toJSON();
        let result = new ListRequest();
        result.init(json);
        return result;
    }
}

export interface IListRequest {
    id?: number | undefined;
    pageSize?: number | undefined;
    pageNumber?: number | undefined;
    sortField: string;
    sortOrderAscending: boolean;
    searchString: string;
    onlyActive: boolean;
}

export class AuditEntriesListRequest extends ListRequest implements IAuditEntriesListRequest {
    functionalityEnum!: FunctionalityEnum;
    entityId!: number;

    constructor(data?: IAuditEntriesListRequest) {
        super(data);
        makeObservable(this, {
            functionalityEnum: observable,
            entityId: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.functionalityEnum = _data["functionalityEnum"];
            this.entityId = _data["entityId"];
        }
    }

    static fromJS(data: any): AuditEntriesListRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuditEntriesListRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["functionalityEnum"] = this.functionalityEnum;
        data["entityId"] = this.entityId;
        super.toJSON(data);
        return data; 
    }

    clone(): AuditEntriesListRequest {
        const json = this.toJSON();
        let result = new AuditEntriesListRequest();
        result.init(json);
        return result;
    }
}

export interface IAuditEntriesListRequest extends IListRequest {
    functionalityEnum: FunctionalityEnum;
    entityId: number;
}

export enum FunctionalityEnum {
    Deals = 1,
    Users = 3,
    Counterparties = 4,
    DealCategories = 5,
    DealTypes = 6,
    DealItemFieldsets = 7,
    Products = 8,
    DealSummaryList = 9,
    SalesForecasts = 10,
    HangfireDashboard = 11,
    Configuration = 12,
    EmsIntegration = 13,
    AsxIntegration = 14,
}

export class ConfigurationGroupsListResponse extends ListResponse implements IConfigurationGroupsListResponse {
    configurationGroups!: ConfigurationGroupsListDto[];

    constructor(data?: IConfigurationGroupsListResponse) {
        super(data);
        if (data) {
            if (data.configurationGroups) {
                this.configurationGroups = [];
                for (let i = 0; i < data.configurationGroups.length; i++) {
                    let item = data.configurationGroups[i];
                    this.configurationGroups[i] = item && !(<any>item).toJSON ? new ConfigurationGroupsListDto(item) : <ConfigurationGroupsListDto>item;
                }
            }
        }
        if (!data) {
            this.configurationGroups = [];
        }
        makeObservable(this, {
            configurationGroups: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["configurationGroups"])) {
                this.configurationGroups = [] as any;
                for (let item of _data["configurationGroups"])
                    this.configurationGroups!.push(ConfigurationGroupsListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConfigurationGroupsListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigurationGroupsListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.configurationGroups)) {
            data["configurationGroups"] = [];
            for (let item of this.configurationGroups)
                data["configurationGroups"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): ConfigurationGroupsListResponse {
        const json = this.toJSON();
        let result = new ConfigurationGroupsListResponse();
        result.init(json);
        return result;
    }
}

export interface IConfigurationGroupsListResponse extends IListResponse {
    configurationGroups: IConfigurationGroupsListDto[];
}

export class ConfigurationGroupsListDto implements IConfigurationGroupsListDto {
    id!: number;
    name!: string;
    description!: string;

    constructor(data?: IConfigurationGroupsListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            id: observable,
            name: observable,
            description: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ConfigurationGroupsListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigurationGroupsListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }

    clone(): ConfigurationGroupsListDto {
        const json = this.toJSON();
        let result = new ConfigurationGroupsListDto();
        result.init(json);
        return result;
    }
}

export interface IConfigurationGroupsListDto {
    id: number;
    name: string;
    description: string;
}

export class ConfigurationGroupsListRequest extends ListRequest implements IConfigurationGroupsListRequest {

    constructor(data?: IConfigurationGroupsListRequest) {
        super(data);
        makeObservable(this, {
        })
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): ConfigurationGroupsListRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigurationGroupsListRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }

    clone(): ConfigurationGroupsListRequest {
        const json = this.toJSON();
        let result = new ConfigurationGroupsListRequest();
        result.init(json);
        return result;
    }
}

export interface IConfigurationGroupsListRequest extends IListRequest {
}

export class ConfigurationGroupDto implements IConfigurationGroupDto {
    id?: number | undefined;
    name!: string;
    description!: string;
    entries!: ConfigurationEntryDto[];

    constructor(data?: IConfigurationGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.entries = [];
        }
        makeObservable(this, {
            id: observable,
            name: observable,
            description: observable,
            entries: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["entries"])) {
                this.entries = [] as any;
                for (let item of _data["entries"])
                    this.entries!.push(ConfigurationEntryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConfigurationGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigurationGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.entries)) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ConfigurationGroupDto {
        const json = this.toJSON();
        let result = new ConfigurationGroupDto();
        result.init(json);
        return result;
    }
}

export interface IConfigurationGroupDto {
    id?: number | undefined;
    name: string;
    description: string;
    entries: ConfigurationEntryDto[];
}

export class UpdatableListItemDto implements IUpdatableListItemDto {
    deleted!: boolean;
    updated!: boolean;
    id?: number | undefined;

    constructor(data?: IUpdatableListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            deleted: observable,
            updated: observable,
            id: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.deleted = _data["deleted"];
            this.updated = _data["updated"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdatableListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatableListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deleted"] = this.deleted;
        data["updated"] = this.updated;
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdatableListItemDto {
        const json = this.toJSON();
        let result = new UpdatableListItemDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatableListItemDto {
    deleted: boolean;
    updated: boolean;
    id?: number | undefined;
}

export class ConfigurationEntryDto extends UpdatableListItemDto implements IConfigurationEntryDto {
    name!: string;
    identifier!: ConfigurationIdentifiersEnum;
    content!: UpdatableOfString;
    contentType!: ConfigurationEntryContentType;
    functionalityForLookup?: FunctionalityEnum | undefined;

    constructor(data?: IConfigurationEntryDto) {
        super(data);
        if (data) {
            this.content = data.content && !(<any>data.content).toJSON ? new UpdatableOfString(data.content) : <UpdatableOfString>this.content; 
        }
        if (!data) {
            this.content = new UpdatableOfString();
        }
        makeObservable(this, {
            name: observable,
            identifier: observable,
            content: observable,
            contentType: observable,
            functionalityForLookup: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.identifier = _data["identifier"];
            this.content = _data["content"] ? UpdatableOfString.fromJS(_data["content"]) : new UpdatableOfString();
            this.contentType = _data["contentType"];
            this.functionalityForLookup = _data["functionalityForLookup"];
        }
    }

    static fromJS(data: any): ConfigurationEntryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigurationEntryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["identifier"] = this.identifier;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        data["contentType"] = this.contentType;
        data["functionalityForLookup"] = this.functionalityForLookup;
        super.toJSON(data);
        return data; 
    }

    clone(): ConfigurationEntryDto {
        const json = this.toJSON();
        let result = new ConfigurationEntryDto();
        result.init(json);
        return result;
    }
}

export interface IConfigurationEntryDto extends IUpdatableListItemDto {
    name: string;
    identifier: ConfigurationIdentifiersEnum;
    content: IUpdatableOfString;
    contentType: ConfigurationEntryContentType;
    functionalityForLookup?: FunctionalityEnum | undefined;
}

export enum ConfigurationIdentifiersEnum {
    TimeOutTransactionScopeIdentifier = 1,
    DealCategoryIdentifier = 2,
    DealTypeIdentifier = 3,
    CounterpartyIdentifier = 4,
    ProductIdentifier = 5,
    WorkflowActionId = 6,
    ShouldReintegrateCancelledDeals = 7,
    EmailAccountsNotifiedOnError = 8,
    ReminderDaysBeforeCounterpartyReviewDate = 9,
    ReminderDaysBeforeDealExpiryDate = 10,
    DealExpiryDatesEmailAccountsNotified = 11,
    CounterpartyExpiryDatesEmailAccountsNotified = 12,
}

export class UpdatableOfString implements IUpdatableOfString {
    updated!: boolean;
    value!: string;

    constructor(data?: IUpdatableOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            updated: observable,
            value: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.updated = _data["updated"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdatableOfString {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatableOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["updated"] = this.updated;
        data["value"] = this.value;
        return data; 
    }

    clone(): UpdatableOfString {
        const json = this.toJSON();
        let result = new UpdatableOfString();
        result.init(json);
        return result;
    }
}

export interface IUpdatableOfString {
    updated: boolean;
    value: string;
}

export enum ConfigurationEntryContentType {
    StringType = 1,
    IntType = 2,
    DecimalType = 3,
    BooleanType = 4,
}

export class ConfigurationGroupPostResponse implements IConfigurationGroupPostResponse {
    name!: string;

    constructor(data?: IConfigurationGroupPostResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            name: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ConfigurationGroupPostResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigurationGroupPostResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): ConfigurationGroupPostResponse {
        const json = this.toJSON();
        let result = new ConfigurationGroupPostResponse();
        result.init(json);
        return result;
    }
}

export interface IConfigurationGroupPostResponse {
    name: string;
}

export class CounterpartiesListResponse extends ListResponse implements ICounterpartiesListResponse {
    counterparties!: CounterpartyListDto[];

    constructor(data?: ICounterpartiesListResponse) {
        super(data);
        if (data) {
            if (data.counterparties) {
                this.counterparties = [];
                for (let i = 0; i < data.counterparties.length; i++) {
                    let item = data.counterparties[i];
                    this.counterparties[i] = item && !(<any>item).toJSON ? new CounterpartyListDto(item) : <CounterpartyListDto>item;
                }
            }
        }
        if (!data) {
            this.counterparties = [];
        }
        makeObservable(this, {
            counterparties: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["counterparties"])) {
                this.counterparties = [] as any;
                for (let item of _data["counterparties"])
                    this.counterparties!.push(CounterpartyListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CounterpartiesListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CounterpartiesListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.counterparties)) {
            data["counterparties"] = [];
            for (let item of this.counterparties)
                data["counterparties"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): CounterpartiesListResponse {
        const json = this.toJSON();
        let result = new CounterpartiesListResponse();
        result.init(json);
        return result;
    }
}

export interface ICounterpartiesListResponse extends IListResponse {
    counterparties: ICounterpartyListDto[];
}

export class CounterpartyListDto implements ICounterpartyListDto {
    id!: number;
    name!: string;
    code!: string;
    active!: boolean;
    exposureLimit!: number;
    expiryDate?: moment.Moment | undefined;

    constructor(data?: ICounterpartyListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            id: observable,
            name: observable,
            code: observable,
            active: observable,
            exposureLimit: observable,
            expiryDate: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.active = _data["active"];
            this.exposureLimit = _data["exposureLimit"];
            this.expiryDate = _data["expiryDate"] ? moment.parseZone(_data["expiryDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CounterpartyListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CounterpartyListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["active"] = this.active;
        data["exposureLimit"] = this.exposureLimit;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString(true) : <any>undefined;
        return data; 
    }

    clone(): CounterpartyListDto {
        const json = this.toJSON();
        let result = new CounterpartyListDto();
        result.init(json);
        return result;
    }
}

export interface ICounterpartyListDto {
    id: number;
    name: string;
    code: string;
    active: boolean;
    exposureLimit: number;
    expiryDate?: moment.Moment | undefined;
}

export class CounterpartiesListRequest extends ListRequest implements ICounterpartiesListRequest {
    dealId?: number | undefined;
    onlyNonExpiredAndApproved?: boolean | undefined;

    constructor(data?: ICounterpartiesListRequest) {
        super(data);
        makeObservable(this, {
            dealId: observable,
            onlyNonExpiredAndApproved: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.dealId = _data["dealId"];
            this.onlyNonExpiredAndApproved = _data["onlyNonExpiredAndApproved"];
        }
    }

    static fromJS(data: any): CounterpartiesListRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CounterpartiesListRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dealId"] = this.dealId;
        data["onlyNonExpiredAndApproved"] = this.onlyNonExpiredAndApproved;
        super.toJSON(data);
        return data; 
    }

    clone(): CounterpartiesListRequest {
        const json = this.toJSON();
        let result = new CounterpartiesListRequest();
        result.init(json);
        return result;
    }
}

export interface ICounterpartiesListRequest extends IListRequest {
    dealId?: number | undefined;
    onlyNonExpiredAndApproved?: boolean | undefined;
}

export class CounterpartyDto extends UpdatableListItemDto implements ICounterpartyDto {
    name!: UpdatableOfString;
    code!: UpdatableOfString;
    active!: UpdatableOfBoolean;
    countryId!: UpdatableOfNullableInteger;
    companyNumber!: UpdatableOfString;
    businessNumber!: UpdatableOfString;
    nzemParticipant!: UpdatableOfNullableBoolean;
    nzemParticipantId!: UpdatableOfString;
    conditions!: UpdatableOfString;
    exposureLimit!: UpdatableOfDecimal;
    expiryDate!: UpdatableOfNullableDateTimeOffset;
    approvalDate!: UpdatableOfNullableDateTimeOffset;
    securityHeld!: UpdatableOfString;
    dealCategories!: number[];

    constructor(data?: ICounterpartyDto) {
        super(data);
        if (data) {
            this.name = data.name && !(<any>data.name).toJSON ? new UpdatableOfString(data.name) : <UpdatableOfString>this.name; 
            this.code = data.code && !(<any>data.code).toJSON ? new UpdatableOfString(data.code) : <UpdatableOfString>this.code; 
            this.active = data.active && !(<any>data.active).toJSON ? new UpdatableOfBoolean(data.active) : <UpdatableOfBoolean>this.active; 
            this.countryId = data.countryId && !(<any>data.countryId).toJSON ? new UpdatableOfNullableInteger(data.countryId) : <UpdatableOfNullableInteger>this.countryId; 
            this.companyNumber = data.companyNumber && !(<any>data.companyNumber).toJSON ? new UpdatableOfString(data.companyNumber) : <UpdatableOfString>this.companyNumber; 
            this.businessNumber = data.businessNumber && !(<any>data.businessNumber).toJSON ? new UpdatableOfString(data.businessNumber) : <UpdatableOfString>this.businessNumber; 
            this.nzemParticipant = data.nzemParticipant && !(<any>data.nzemParticipant).toJSON ? new UpdatableOfNullableBoolean(data.nzemParticipant) : <UpdatableOfNullableBoolean>this.nzemParticipant; 
            this.nzemParticipantId = data.nzemParticipantId && !(<any>data.nzemParticipantId).toJSON ? new UpdatableOfString(data.nzemParticipantId) : <UpdatableOfString>this.nzemParticipantId; 
            this.conditions = data.conditions && !(<any>data.conditions).toJSON ? new UpdatableOfString(data.conditions) : <UpdatableOfString>this.conditions; 
            this.exposureLimit = data.exposureLimit && !(<any>data.exposureLimit).toJSON ? new UpdatableOfDecimal(data.exposureLimit) : <UpdatableOfDecimal>this.exposureLimit; 
            this.expiryDate = data.expiryDate && !(<any>data.expiryDate).toJSON ? new UpdatableOfNullableDateTimeOffset(data.expiryDate) : <UpdatableOfNullableDateTimeOffset>this.expiryDate; 
            this.approvalDate = data.approvalDate && !(<any>data.approvalDate).toJSON ? new UpdatableOfNullableDateTimeOffset(data.approvalDate) : <UpdatableOfNullableDateTimeOffset>this.approvalDate; 
            this.securityHeld = data.securityHeld && !(<any>data.securityHeld).toJSON ? new UpdatableOfString(data.securityHeld) : <UpdatableOfString>this.securityHeld; 
        }
        if (!data) {
            this.name = new UpdatableOfString();
            this.code = new UpdatableOfString();
            this.active = new UpdatableOfBoolean();
            this.countryId = new UpdatableOfNullableInteger();
            this.companyNumber = new UpdatableOfString();
            this.businessNumber = new UpdatableOfString();
            this.nzemParticipant = new UpdatableOfNullableBoolean();
            this.nzemParticipantId = new UpdatableOfString();
            this.conditions = new UpdatableOfString();
            this.exposureLimit = new UpdatableOfDecimal();
            this.expiryDate = new UpdatableOfNullableDateTimeOffset();
            this.approvalDate = new UpdatableOfNullableDateTimeOffset();
            this.securityHeld = new UpdatableOfString();
            this.dealCategories = [];
        }
        makeObservable(this, {
            name: observable,
            code: observable,
            active: observable,
            countryId: observable,
            companyNumber: observable,
            businessNumber: observable,
            nzemParticipant: observable,
            nzemParticipantId: observable,
            conditions: observable,
            exposureLimit: observable,
            expiryDate: observable,
            approvalDate: observable,
            securityHeld: observable,
            dealCategories: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"] ? UpdatableOfString.fromJS(_data["name"]) : new UpdatableOfString();
            this.code = _data["code"] ? UpdatableOfString.fromJS(_data["code"]) : new UpdatableOfString();
            this.active = _data["active"] ? UpdatableOfBoolean.fromJS(_data["active"]) : new UpdatableOfBoolean();
            this.countryId = _data["countryId"] ? UpdatableOfNullableInteger.fromJS(_data["countryId"]) : new UpdatableOfNullableInteger();
            this.companyNumber = _data["companyNumber"] ? UpdatableOfString.fromJS(_data["companyNumber"]) : new UpdatableOfString();
            this.businessNumber = _data["businessNumber"] ? UpdatableOfString.fromJS(_data["businessNumber"]) : new UpdatableOfString();
            this.nzemParticipant = _data["nzemParticipant"] ? UpdatableOfNullableBoolean.fromJS(_data["nzemParticipant"]) : new UpdatableOfNullableBoolean();
            this.nzemParticipantId = _data["nzemParticipantId"] ? UpdatableOfString.fromJS(_data["nzemParticipantId"]) : new UpdatableOfString();
            this.conditions = _data["conditions"] ? UpdatableOfString.fromJS(_data["conditions"]) : new UpdatableOfString();
            this.exposureLimit = _data["exposureLimit"] ? UpdatableOfDecimal.fromJS(_data["exposureLimit"]) : new UpdatableOfDecimal();
            this.expiryDate = _data["expiryDate"] ? UpdatableOfNullableDateTimeOffset.fromJS(_data["expiryDate"]) : new UpdatableOfNullableDateTimeOffset();
            this.approvalDate = _data["approvalDate"] ? UpdatableOfNullableDateTimeOffset.fromJS(_data["approvalDate"]) : new UpdatableOfNullableDateTimeOffset();
            this.securityHeld = _data["securityHeld"] ? UpdatableOfString.fromJS(_data["securityHeld"]) : new UpdatableOfString();
            if (Array.isArray(_data["dealCategories"])) {
                this.dealCategories = [] as any;
                for (let item of _data["dealCategories"])
                    this.dealCategories!.push(item);
            }
        }
    }

    static fromJS(data: any): CounterpartyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CounterpartyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["code"] = this.code ? this.code.toJSON() : <any>undefined;
        data["active"] = this.active ? this.active.toJSON() : <any>undefined;
        data["countryId"] = this.countryId ? this.countryId.toJSON() : <any>undefined;
        data["companyNumber"] = this.companyNumber ? this.companyNumber.toJSON() : <any>undefined;
        data["businessNumber"] = this.businessNumber ? this.businessNumber.toJSON() : <any>undefined;
        data["nzemParticipant"] = this.nzemParticipant ? this.nzemParticipant.toJSON() : <any>undefined;
        data["nzemParticipantId"] = this.nzemParticipantId ? this.nzemParticipantId.toJSON() : <any>undefined;
        data["conditions"] = this.conditions ? this.conditions.toJSON() : <any>undefined;
        data["exposureLimit"] = this.exposureLimit ? this.exposureLimit.toJSON() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toJSON() : <any>undefined;
        data["approvalDate"] = this.approvalDate ? this.approvalDate.toJSON() : <any>undefined;
        data["securityHeld"] = this.securityHeld ? this.securityHeld.toJSON() : <any>undefined;
        if (Array.isArray(this.dealCategories)) {
            data["dealCategories"] = [];
            for (let item of this.dealCategories)
                data["dealCategories"].push(item);
        }
        super.toJSON(data);
        return data; 
    }

    clone(): CounterpartyDto {
        const json = this.toJSON();
        let result = new CounterpartyDto();
        result.init(json);
        return result;
    }
}

export interface ICounterpartyDto extends IUpdatableListItemDto {
    name: IUpdatableOfString;
    code: IUpdatableOfString;
    active: IUpdatableOfBoolean;
    countryId: IUpdatableOfNullableInteger;
    companyNumber: IUpdatableOfString;
    businessNumber: IUpdatableOfString;
    nzemParticipant: IUpdatableOfNullableBoolean;
    nzemParticipantId: IUpdatableOfString;
    conditions: IUpdatableOfString;
    exposureLimit: IUpdatableOfDecimal;
    expiryDate: IUpdatableOfNullableDateTimeOffset;
    approvalDate: IUpdatableOfNullableDateTimeOffset;
    securityHeld: IUpdatableOfString;
    dealCategories: number[];
}

export class UpdatableOfBoolean implements IUpdatableOfBoolean {
    updated!: boolean;
    value!: boolean;

    constructor(data?: IUpdatableOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            updated: observable,
            value: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.updated = _data["updated"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdatableOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatableOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["updated"] = this.updated;
        data["value"] = this.value;
        return data; 
    }

    clone(): UpdatableOfBoolean {
        const json = this.toJSON();
        let result = new UpdatableOfBoolean();
        result.init(json);
        return result;
    }
}

export interface IUpdatableOfBoolean {
    updated: boolean;
    value: boolean;
}

export class UpdatableOfNullableInteger implements IUpdatableOfNullableInteger {
    updated!: boolean;
    value?: number | undefined;

    constructor(data?: IUpdatableOfNullableInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            updated: observable,
            value: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.updated = _data["updated"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdatableOfNullableInteger {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatableOfNullableInteger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["updated"] = this.updated;
        data["value"] = this.value;
        return data; 
    }

    clone(): UpdatableOfNullableInteger {
        const json = this.toJSON();
        let result = new UpdatableOfNullableInteger();
        result.init(json);
        return result;
    }
}

export interface IUpdatableOfNullableInteger {
    updated: boolean;
    value?: number | undefined;
}

export class UpdatableOfNullableBoolean implements IUpdatableOfNullableBoolean {
    updated!: boolean;
    value?: boolean | undefined;

    constructor(data?: IUpdatableOfNullableBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            updated: observable,
            value: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.updated = _data["updated"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdatableOfNullableBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatableOfNullableBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["updated"] = this.updated;
        data["value"] = this.value;
        return data; 
    }

    clone(): UpdatableOfNullableBoolean {
        const json = this.toJSON();
        let result = new UpdatableOfNullableBoolean();
        result.init(json);
        return result;
    }
}

export interface IUpdatableOfNullableBoolean {
    updated: boolean;
    value?: boolean | undefined;
}

export class UpdatableOfDecimal implements IUpdatableOfDecimal {
    updated!: boolean;
    value!: number;

    constructor(data?: IUpdatableOfDecimal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            updated: observable,
            value: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.updated = _data["updated"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdatableOfDecimal {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatableOfDecimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["updated"] = this.updated;
        data["value"] = this.value;
        return data; 
    }

    clone(): UpdatableOfDecimal {
        const json = this.toJSON();
        let result = new UpdatableOfDecimal();
        result.init(json);
        return result;
    }
}

export interface IUpdatableOfDecimal {
    updated: boolean;
    value: number;
}

export class UpdatableOfNullableDateTimeOffset implements IUpdatableOfNullableDateTimeOffset {
    updated!: boolean;
    value?: moment.Moment | undefined;

    constructor(data?: IUpdatableOfNullableDateTimeOffset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            updated: observable,
            value: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.updated = _data["updated"];
            this.value = _data["value"] ? moment.parseZone(_data["value"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdatableOfNullableDateTimeOffset {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatableOfNullableDateTimeOffset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["updated"] = this.updated;
        data["value"] = this.value ? this.value.toISOString(true) : <any>undefined;
        return data; 
    }

    clone(): UpdatableOfNullableDateTimeOffset {
        const json = this.toJSON();
        let result = new UpdatableOfNullableDateTimeOffset();
        result.init(json);
        return result;
    }
}

export interface IUpdatableOfNullableDateTimeOffset {
    updated: boolean;
    value?: moment.Moment | undefined;
}

export class CounterpartyPostResponse implements ICounterpartyPostResponse {
    counterpartyName!: string;

    constructor(data?: ICounterpartyPostResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            counterpartyName: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.counterpartyName = _data["counterpartyName"];
        }
    }

    static fromJS(data: any): CounterpartyPostResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CounterpartyPostResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["counterpartyName"] = this.counterpartyName;
        return data; 
    }

    clone(): CounterpartyPostResponse {
        const json = this.toJSON();
        let result = new CounterpartyPostResponse();
        result.init(json);
        return result;
    }
}

export interface ICounterpartyPostResponse {
    counterpartyName: string;
}

export class LookupRequest implements ILookupRequest {
    id!: number;
    name!: string;
    description!: string;
    active?: boolean | undefined;

    constructor(data?: ILookupRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            id: observable,
            name: observable,
            description: observable,
            active: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): LookupRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LookupRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["active"] = this.active;
        return data; 
    }

    clone(): LookupRequest {
        const json = this.toJSON();
        let result = new LookupRequest();
        result.init(json);
        return result;
    }
}

export interface ILookupRequest {
    id: number;
    name: string;
    description: string;
    active?: boolean | undefined;
}

export class DealCategoriesListResponse extends ListResponse implements IDealCategoriesListResponse {
    dealCategories!: DealCategoryListDto[];

    constructor(data?: IDealCategoriesListResponse) {
        super(data);
        if (data) {
            if (data.dealCategories) {
                this.dealCategories = [];
                for (let i = 0; i < data.dealCategories.length; i++) {
                    let item = data.dealCategories[i];
                    this.dealCategories[i] = item && !(<any>item).toJSON ? new DealCategoryListDto(item) : <DealCategoryListDto>item;
                }
            }
        }
        if (!data) {
            this.dealCategories = [];
        }
        makeObservable(this, {
            dealCategories: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["dealCategories"])) {
                this.dealCategories = [] as any;
                for (let item of _data["dealCategories"])
                    this.dealCategories!.push(DealCategoryListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DealCategoriesListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DealCategoriesListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dealCategories)) {
            data["dealCategories"] = [];
            for (let item of this.dealCategories)
                data["dealCategories"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): DealCategoriesListResponse {
        const json = this.toJSON();
        let result = new DealCategoriesListResponse();
        result.init(json);
        return result;
    }
}

export interface IDealCategoriesListResponse extends IListResponse {
    dealCategories: IDealCategoryListDto[];
}

export class DealCategoryListDto implements IDealCategoryListDto {
    id!: number;
    name!: string;
    unitOfMeasure!: string;
    active!: boolean;

    constructor(data?: IDealCategoryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            id: observable,
            name: observable,
            unitOfMeasure: observable,
            active: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): DealCategoryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealCategoryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["active"] = this.active;
        return data; 
    }

    clone(): DealCategoryListDto {
        const json = this.toJSON();
        let result = new DealCategoryListDto();
        result.init(json);
        return result;
    }
}

export interface IDealCategoryListDto {
    id: number;
    name: string;
    unitOfMeasure: string;
    active: boolean;
}

export class DealCategoriesListRequest extends ListRequest implements IDealCategoriesListRequest {

    constructor(data?: IDealCategoriesListRequest) {
        super(data);
        makeObservable(this, {
        })
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): DealCategoriesListRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DealCategoriesListRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }

    clone(): DealCategoriesListRequest {
        const json = this.toJSON();
        let result = new DealCategoriesListRequest();
        result.init(json);
        return result;
    }
}

export interface IDealCategoriesListRequest extends IListRequest {
}

export class DealCategoryDto extends UpdatableListItemDto implements IDealCategoryDto {
    name!: UpdatableOfString;
    unitOfMeasure!: UpdatableOfString;
    active!: UpdatableOfBoolean;

    constructor(data?: IDealCategoryDto) {
        super(data);
        if (data) {
            this.name = data.name && !(<any>data.name).toJSON ? new UpdatableOfString(data.name) : <UpdatableOfString>this.name; 
            this.unitOfMeasure = data.unitOfMeasure && !(<any>data.unitOfMeasure).toJSON ? new UpdatableOfString(data.unitOfMeasure) : <UpdatableOfString>this.unitOfMeasure; 
            this.active = data.active && !(<any>data.active).toJSON ? new UpdatableOfBoolean(data.active) : <UpdatableOfBoolean>this.active; 
        }
        if (!data) {
            this.name = new UpdatableOfString();
            this.unitOfMeasure = new UpdatableOfString();
            this.active = new UpdatableOfBoolean();
        }
        makeObservable(this, {
            name: observable,
            unitOfMeasure: observable,
            active: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"] ? UpdatableOfString.fromJS(_data["name"]) : new UpdatableOfString();
            this.unitOfMeasure = _data["unitOfMeasure"] ? UpdatableOfString.fromJS(_data["unitOfMeasure"]) : new UpdatableOfString();
            this.active = _data["active"] ? UpdatableOfBoolean.fromJS(_data["active"]) : new UpdatableOfBoolean();
        }
    }

    static fromJS(data: any): DealCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["unitOfMeasure"] = this.unitOfMeasure ? this.unitOfMeasure.toJSON() : <any>undefined;
        data["active"] = this.active ? this.active.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }

    clone(): DealCategoryDto {
        const json = this.toJSON();
        let result = new DealCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IDealCategoryDto extends IUpdatableListItemDto {
    name: IUpdatableOfString;
    unitOfMeasure: IUpdatableOfString;
    active: IUpdatableOfBoolean;
}

export class DealCategoryPostResponse implements IDealCategoryPostResponse {
    dealCategoryName!: string;

    constructor(data?: IDealCategoryPostResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            dealCategoryName: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.dealCategoryName = _data["dealCategoryName"];
        }
    }

    static fromJS(data: any): DealCategoryPostResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DealCategoryPostResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dealCategoryName"] = this.dealCategoryName;
        return data; 
    }

    clone(): DealCategoryPostResponse {
        const json = this.toJSON();
        let result = new DealCategoryPostResponse();
        result.init(json);
        return result;
    }
}

export interface IDealCategoryPostResponse {
    dealCategoryName: string;
}

export class DealsListResponse extends ListResponse implements IDealsListResponse {
    deals!: DealListDto[];

    constructor(data?: IDealsListResponse) {
        super(data);
        if (data) {
            if (data.deals) {
                this.deals = [];
                for (let i = 0; i < data.deals.length; i++) {
                    let item = data.deals[i];
                    this.deals[i] = item && !(<any>item).toJSON ? new DealListDto(item) : <DealListDto>item;
                }
            }
        }
        if (!data) {
            this.deals = [];
        }
        makeObservable(this, {
            deals: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["deals"])) {
                this.deals = [] as any;
                for (let item of _data["deals"])
                    this.deals!.push(DealListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DealsListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DealsListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.deals)) {
            data["deals"] = [];
            for (let item of this.deals)
                data["deals"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): DealsListResponse {
        const json = this.toJSON();
        let result = new DealsListResponse();
        result.init(json);
        return result;
    }
}

export interface IDealsListResponse extends IListResponse {
    deals: IDealListDto[];
}

export class DealListDto implements IDealListDto {
    id!: number;
    dealNumber!: string;
    dealStatusName!: string;
    counterpartyName!: string;
    dealCategoryId!: number;
    dealCategoryName!: string;
    dealTypeName!: string;
    forceMajeure!: boolean;
    assignedTo!: string;
    executed!: boolean;
    isExecutionStatus!: boolean;
    creationDate!: moment.Moment;
    creationUserName!: string;

    constructor(data?: IDealListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            id: observable,
            dealNumber: observable,
            dealStatusName: observable,
            counterpartyName: observable,
            dealCategoryId: observable,
            dealCategoryName: observable,
            dealTypeName: observable,
            forceMajeure: observable,
            assignedTo: observable,
            executed: observable,
            isExecutionStatus: observable,
            creationDate: observable,
            creationUserName: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dealNumber = _data["dealNumber"];
            this.dealStatusName = _data["dealStatusName"];
            this.counterpartyName = _data["counterpartyName"];
            this.dealCategoryId = _data["dealCategoryId"];
            this.dealCategoryName = _data["dealCategoryName"];
            this.dealTypeName = _data["dealTypeName"];
            this.forceMajeure = _data["forceMajeure"];
            this.assignedTo = _data["assignedTo"];
            this.executed = _data["executed"];
            this.isExecutionStatus = _data["isExecutionStatus"];
            this.creationDate = _data["creationDate"] ? moment.parseZone(_data["creationDate"].toString()) : <any>undefined;
            this.creationUserName = _data["creationUserName"];
        }
    }

    static fromJS(data: any): DealListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dealNumber"] = this.dealNumber;
        data["dealStatusName"] = this.dealStatusName;
        data["counterpartyName"] = this.counterpartyName;
        data["dealCategoryId"] = this.dealCategoryId;
        data["dealCategoryName"] = this.dealCategoryName;
        data["dealTypeName"] = this.dealTypeName;
        data["forceMajeure"] = this.forceMajeure;
        data["assignedTo"] = this.assignedTo;
        data["executed"] = this.executed;
        data["isExecutionStatus"] = this.isExecutionStatus;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString(true) : <any>undefined;
        data["creationUserName"] = this.creationUserName;
        return data; 
    }

    clone(): DealListDto {
        const json = this.toJSON();
        let result = new DealListDto();
        result.init(json);
        return result;
    }
}

export interface IDealListDto {
    id: number;
    dealNumber: string;
    dealStatusName: string;
    counterpartyName: string;
    dealCategoryId: number;
    dealCategoryName: string;
    dealTypeName: string;
    forceMajeure: boolean;
    assignedTo: string;
    executed: boolean;
    isExecutionStatus: boolean;
    creationDate: moment.Moment;
    creationUserName: string;
}

export class DealsListRequest extends ListRequest implements IDealsListRequest {
    dealId?: number | undefined;
    onlyDealsAssignedToMeOrMyRole!: boolean;
    includeFinalizedDeals!: boolean;
    startCreationDate?: moment.Moment | undefined;
    endCreationDate?: moment.Moment | undefined;

    constructor(data?: IDealsListRequest) {
        super(data);
        makeObservable(this, {
            dealId: observable,
            onlyDealsAssignedToMeOrMyRole: observable,
            includeFinalizedDeals: observable,
            startCreationDate: observable,
            endCreationDate: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.dealId = _data["dealId"];
            this.onlyDealsAssignedToMeOrMyRole = _data["onlyDealsAssignedToMeOrMyRole"];
            this.includeFinalizedDeals = _data["includeFinalizedDeals"];
            this.startCreationDate = _data["startCreationDate"] ? moment.parseZone(_data["startCreationDate"].toString()) : <any>undefined;
            this.endCreationDate = _data["endCreationDate"] ? moment.parseZone(_data["endCreationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DealsListRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DealsListRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dealId"] = this.dealId;
        data["onlyDealsAssignedToMeOrMyRole"] = this.onlyDealsAssignedToMeOrMyRole;
        data["includeFinalizedDeals"] = this.includeFinalizedDeals;
        data["startCreationDate"] = this.startCreationDate ? this.startCreationDate.toISOString(true) : <any>undefined;
        data["endCreationDate"] = this.endCreationDate ? this.endCreationDate.toISOString(true) : <any>undefined;
        super.toJSON(data);
        return data; 
    }

    clone(): DealsListRequest {
        const json = this.toJSON();
        let result = new DealsListRequest();
        result.init(json);
        return result;
    }
}

export interface IDealsListRequest extends IListRequest {
    dealId?: number | undefined;
    onlyDealsAssignedToMeOrMyRole: boolean;
    includeFinalizedDeals: boolean;
    startCreationDate?: moment.Moment | undefined;
    endCreationDate?: moment.Moment | undefined;
}

export class DealDto implements IDealDto {
    id?: number | undefined;
    dealNumber!: string;
    dealStatusName!: string;
    assignedToSelf!: boolean;
    userParticipatedOnThisDeal!: boolean;
    currentUserId!: number;
    dealCategoryId!: UpdatableOfNullableInteger;
    dealTypeId!: UpdatableOfNullableInteger;
    counterpartyId!: UpdatableOfNullableInteger;
    counterpartyName!: string;
    forceMajeure!: UpdatableOfBoolean;
    expiryDate!: UpdatableOfNullableDateTimeOffset;
    dealItemFieldsetId!: UpdatableOfNullableInteger;
    workflowSetId!: UpdatableOfNullableInteger;
    currentDealWorkflowStatusId?: number | undefined;
    nextDealWorkflowStatusId?: number | undefined;
    termInMonthsOverride!: UpdatableOfNullableInteger;
    ongoingWorkflowActionId!: UpdatableOfNullableInteger;
    ongoingWorkflowActionNote!: string;
    completedActionId?: number | undefined;
    executed!: boolean;
    executionDate!: UpdatableOfNullableDateTimeOffset;
    creationDate!: moment.Moment;
    isExecutionStatus!: boolean;
    submissionDate?: moment.Moment | undefined;
    submissionUserId?: number | undefined;
    delegatedAuthorityUserId!: UpdatableOfNullableInteger;
    delegatedAuthorityUserName!: string;
    dealWorkflowStatuses!: DealWorkflowStatusDto[];
    possibleAssignments!: DealWorkflowAssignmentDto[];
    items!: LazyLoadedDataOfListOfDealItemDto;
    notes!: LazyLoadedDataOfListOfDealNoteDto;
    attachments!: LazyLoadedDataOfListOfDealAttachmentDto;

    constructor(data?: IDealDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.dealCategoryId = data.dealCategoryId && !(<any>data.dealCategoryId).toJSON ? new UpdatableOfNullableInteger(data.dealCategoryId) : <UpdatableOfNullableInteger>this.dealCategoryId; 
            this.dealTypeId = data.dealTypeId && !(<any>data.dealTypeId).toJSON ? new UpdatableOfNullableInteger(data.dealTypeId) : <UpdatableOfNullableInteger>this.dealTypeId; 
            this.counterpartyId = data.counterpartyId && !(<any>data.counterpartyId).toJSON ? new UpdatableOfNullableInteger(data.counterpartyId) : <UpdatableOfNullableInteger>this.counterpartyId; 
            this.forceMajeure = data.forceMajeure && !(<any>data.forceMajeure).toJSON ? new UpdatableOfBoolean(data.forceMajeure) : <UpdatableOfBoolean>this.forceMajeure; 
            this.expiryDate = data.expiryDate && !(<any>data.expiryDate).toJSON ? new UpdatableOfNullableDateTimeOffset(data.expiryDate) : <UpdatableOfNullableDateTimeOffset>this.expiryDate; 
            this.dealItemFieldsetId = data.dealItemFieldsetId && !(<any>data.dealItemFieldsetId).toJSON ? new UpdatableOfNullableInteger(data.dealItemFieldsetId) : <UpdatableOfNullableInteger>this.dealItemFieldsetId; 
            this.workflowSetId = data.workflowSetId && !(<any>data.workflowSetId).toJSON ? new UpdatableOfNullableInteger(data.workflowSetId) : <UpdatableOfNullableInteger>this.workflowSetId; 
            this.termInMonthsOverride = data.termInMonthsOverride && !(<any>data.termInMonthsOverride).toJSON ? new UpdatableOfNullableInteger(data.termInMonthsOverride) : <UpdatableOfNullableInteger>this.termInMonthsOverride; 
            this.ongoingWorkflowActionId = data.ongoingWorkflowActionId && !(<any>data.ongoingWorkflowActionId).toJSON ? new UpdatableOfNullableInteger(data.ongoingWorkflowActionId) : <UpdatableOfNullableInteger>this.ongoingWorkflowActionId; 
            this.executionDate = data.executionDate && !(<any>data.executionDate).toJSON ? new UpdatableOfNullableDateTimeOffset(data.executionDate) : <UpdatableOfNullableDateTimeOffset>this.executionDate; 
            this.delegatedAuthorityUserId = data.delegatedAuthorityUserId && !(<any>data.delegatedAuthorityUserId).toJSON ? new UpdatableOfNullableInteger(data.delegatedAuthorityUserId) : <UpdatableOfNullableInteger>this.delegatedAuthorityUserId; 
            if (data.possibleAssignments) {
                this.possibleAssignments = [];
                for (let i = 0; i < data.possibleAssignments.length; i++) {
                    let item = data.possibleAssignments[i];
                    this.possibleAssignments[i] = item && !(<any>item).toJSON ? new DealWorkflowAssignmentDto(item) : <DealWorkflowAssignmentDto>item;
                }
            }
            this.items = data.items && !(<any>data.items).toJSON ? new LazyLoadedDataOfListOfDealItemDto(data.items) : <LazyLoadedDataOfListOfDealItemDto>this.items; 
            this.notes = data.notes && !(<any>data.notes).toJSON ? new LazyLoadedDataOfListOfDealNoteDto(data.notes) : <LazyLoadedDataOfListOfDealNoteDto>this.notes; 
            this.attachments = data.attachments && !(<any>data.attachments).toJSON ? new LazyLoadedDataOfListOfDealAttachmentDto(data.attachments) : <LazyLoadedDataOfListOfDealAttachmentDto>this.attachments; 
        }
        if (!data) {
            this.dealCategoryId = new UpdatableOfNullableInteger();
            this.dealTypeId = new UpdatableOfNullableInteger();
            this.counterpartyId = new UpdatableOfNullableInteger();
            this.forceMajeure = new UpdatableOfBoolean();
            this.expiryDate = new UpdatableOfNullableDateTimeOffset();
            this.dealItemFieldsetId = new UpdatableOfNullableInteger();
            this.workflowSetId = new UpdatableOfNullableInteger();
            this.termInMonthsOverride = new UpdatableOfNullableInteger();
            this.ongoingWorkflowActionId = new UpdatableOfNullableInteger();
            this.executionDate = new UpdatableOfNullableDateTimeOffset();
            this.delegatedAuthorityUserId = new UpdatableOfNullableInteger();
            this.dealWorkflowStatuses = [];
            this.possibleAssignments = [];
            this.items = new LazyLoadedDataOfListOfDealItemDto();
            this.notes = new LazyLoadedDataOfListOfDealNoteDto();
            this.attachments = new LazyLoadedDataOfListOfDealAttachmentDto();
        }
        makeObservable(this, {
            id: observable,
            dealNumber: observable,
            dealStatusName: observable,
            assignedToSelf: observable,
            userParticipatedOnThisDeal: observable,
            currentUserId: observable,
            dealCategoryId: observable,
            dealTypeId: observable,
            counterpartyId: observable,
            counterpartyName: observable,
            forceMajeure: observable,
            expiryDate: observable,
            dealItemFieldsetId: observable,
            workflowSetId: observable,
            currentDealWorkflowStatusId: observable,
            nextDealWorkflowStatusId: observable,
            termInMonthsOverride: observable,
            ongoingWorkflowActionId: observable,
            ongoingWorkflowActionNote: observable,
            completedActionId: observable,
            executed: observable,
            executionDate: observable,
            creationDate: observable,
            isExecutionStatus: observable,
            submissionDate: observable,
            submissionUserId: observable,
            delegatedAuthorityUserId: observable,
            delegatedAuthorityUserName: observable,
            dealWorkflowStatuses: observable,
            possibleAssignments: observable,
            items: observable,
            notes: observable,
            attachments: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dealNumber = _data["dealNumber"];
            this.dealStatusName = _data["dealStatusName"];
            this.assignedToSelf = _data["assignedToSelf"];
            this.userParticipatedOnThisDeal = _data["userParticipatedOnThisDeal"];
            this.currentUserId = _data["currentUserId"];
            this.dealCategoryId = _data["dealCategoryId"] ? UpdatableOfNullableInteger.fromJS(_data["dealCategoryId"]) : new UpdatableOfNullableInteger();
            this.dealTypeId = _data["dealTypeId"] ? UpdatableOfNullableInteger.fromJS(_data["dealTypeId"]) : new UpdatableOfNullableInteger();
            this.counterpartyId = _data["counterpartyId"] ? UpdatableOfNullableInteger.fromJS(_data["counterpartyId"]) : new UpdatableOfNullableInteger();
            this.counterpartyName = _data["counterpartyName"];
            this.forceMajeure = _data["forceMajeure"] ? UpdatableOfBoolean.fromJS(_data["forceMajeure"]) : new UpdatableOfBoolean();
            this.expiryDate = _data["expiryDate"] ? UpdatableOfNullableDateTimeOffset.fromJS(_data["expiryDate"]) : new UpdatableOfNullableDateTimeOffset();
            this.dealItemFieldsetId = _data["dealItemFieldsetId"] ? UpdatableOfNullableInteger.fromJS(_data["dealItemFieldsetId"]) : new UpdatableOfNullableInteger();
            this.workflowSetId = _data["workflowSetId"] ? UpdatableOfNullableInteger.fromJS(_data["workflowSetId"]) : new UpdatableOfNullableInteger();
            this.currentDealWorkflowStatusId = _data["currentDealWorkflowStatusId"];
            this.nextDealWorkflowStatusId = _data["nextDealWorkflowStatusId"];
            this.termInMonthsOverride = _data["termInMonthsOverride"] ? UpdatableOfNullableInteger.fromJS(_data["termInMonthsOverride"]) : new UpdatableOfNullableInteger();
            this.ongoingWorkflowActionId = _data["ongoingWorkflowActionId"] ? UpdatableOfNullableInteger.fromJS(_data["ongoingWorkflowActionId"]) : new UpdatableOfNullableInteger();
            this.ongoingWorkflowActionNote = _data["ongoingWorkflowActionNote"];
            this.completedActionId = _data["completedActionId"];
            this.executed = _data["executed"];
            this.executionDate = _data["executionDate"] ? UpdatableOfNullableDateTimeOffset.fromJS(_data["executionDate"]) : new UpdatableOfNullableDateTimeOffset();
            this.creationDate = _data["creationDate"] ? moment.parseZone(_data["creationDate"].toString()) : <any>undefined;
            this.isExecutionStatus = _data["isExecutionStatus"];
            this.submissionDate = _data["submissionDate"] ? moment.parseZone(_data["submissionDate"].toString()) : <any>undefined;
            this.submissionUserId = _data["submissionUserId"];
            this.delegatedAuthorityUserId = _data["delegatedAuthorityUserId"] ? UpdatableOfNullableInteger.fromJS(_data["delegatedAuthorityUserId"]) : new UpdatableOfNullableInteger();
            this.delegatedAuthorityUserName = _data["delegatedAuthorityUserName"];
            if (Array.isArray(_data["dealWorkflowStatuses"])) {
                this.dealWorkflowStatuses = [] as any;
                for (let item of _data["dealWorkflowStatuses"])
                    this.dealWorkflowStatuses!.push(DealWorkflowStatusDto.fromJS(item));
            }
            if (Array.isArray(_data["possibleAssignments"])) {
                this.possibleAssignments = [] as any;
                for (let item of _data["possibleAssignments"])
                    this.possibleAssignments!.push(DealWorkflowAssignmentDto.fromJS(item));
            }
            this.items = _data["items"] ? LazyLoadedDataOfListOfDealItemDto.fromJS(_data["items"]) : new LazyLoadedDataOfListOfDealItemDto();
            this.notes = _data["notes"] ? LazyLoadedDataOfListOfDealNoteDto.fromJS(_data["notes"]) : new LazyLoadedDataOfListOfDealNoteDto();
            this.attachments = _data["attachments"] ? LazyLoadedDataOfListOfDealAttachmentDto.fromJS(_data["attachments"]) : new LazyLoadedDataOfListOfDealAttachmentDto();
        }
    }

    static fromJS(data: any): DealDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dealNumber"] = this.dealNumber;
        data["dealStatusName"] = this.dealStatusName;
        data["assignedToSelf"] = this.assignedToSelf;
        data["userParticipatedOnThisDeal"] = this.userParticipatedOnThisDeal;
        data["currentUserId"] = this.currentUserId;
        data["dealCategoryId"] = this.dealCategoryId ? this.dealCategoryId.toJSON() : <any>undefined;
        data["dealTypeId"] = this.dealTypeId ? this.dealTypeId.toJSON() : <any>undefined;
        data["counterpartyId"] = this.counterpartyId ? this.counterpartyId.toJSON() : <any>undefined;
        data["counterpartyName"] = this.counterpartyName;
        data["forceMajeure"] = this.forceMajeure ? this.forceMajeure.toJSON() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toJSON() : <any>undefined;
        data["dealItemFieldsetId"] = this.dealItemFieldsetId ? this.dealItemFieldsetId.toJSON() : <any>undefined;
        data["workflowSetId"] = this.workflowSetId ? this.workflowSetId.toJSON() : <any>undefined;
        data["currentDealWorkflowStatusId"] = this.currentDealWorkflowStatusId;
        data["nextDealWorkflowStatusId"] = this.nextDealWorkflowStatusId;
        data["termInMonthsOverride"] = this.termInMonthsOverride ? this.termInMonthsOverride.toJSON() : <any>undefined;
        data["ongoingWorkflowActionId"] = this.ongoingWorkflowActionId ? this.ongoingWorkflowActionId.toJSON() : <any>undefined;
        data["ongoingWorkflowActionNote"] = this.ongoingWorkflowActionNote;
        data["completedActionId"] = this.completedActionId;
        data["executed"] = this.executed;
        data["executionDate"] = this.executionDate ? this.executionDate.toJSON() : <any>undefined;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString(true) : <any>undefined;
        data["isExecutionStatus"] = this.isExecutionStatus;
        data["submissionDate"] = this.submissionDate ? this.submissionDate.toISOString(true) : <any>undefined;
        data["submissionUserId"] = this.submissionUserId;
        data["delegatedAuthorityUserId"] = this.delegatedAuthorityUserId ? this.delegatedAuthorityUserId.toJSON() : <any>undefined;
        data["delegatedAuthorityUserName"] = this.delegatedAuthorityUserName;
        if (Array.isArray(this.dealWorkflowStatuses)) {
            data["dealWorkflowStatuses"] = [];
            for (let item of this.dealWorkflowStatuses)
                data["dealWorkflowStatuses"].push(item.toJSON());
        }
        if (Array.isArray(this.possibleAssignments)) {
            data["possibleAssignments"] = [];
            for (let item of this.possibleAssignments)
                data["possibleAssignments"].push(item.toJSON());
        }
        data["items"] = this.items ? this.items.toJSON() : <any>undefined;
        data["notes"] = this.notes ? this.notes.toJSON() : <any>undefined;
        data["attachments"] = this.attachments ? this.attachments.toJSON() : <any>undefined;
        return data; 
    }

    clone(): DealDto {
        const json = this.toJSON();
        let result = new DealDto();
        result.init(json);
        return result;
    }
}

export interface IDealDto {
    id?: number | undefined;
    dealNumber: string;
    dealStatusName: string;
    assignedToSelf: boolean;
    userParticipatedOnThisDeal: boolean;
    currentUserId: number;
    dealCategoryId: IUpdatableOfNullableInteger;
    dealTypeId: IUpdatableOfNullableInteger;
    counterpartyId: IUpdatableOfNullableInteger;
    counterpartyName: string;
    forceMajeure: IUpdatableOfBoolean;
    expiryDate: IUpdatableOfNullableDateTimeOffset;
    dealItemFieldsetId: IUpdatableOfNullableInteger;
    workflowSetId: IUpdatableOfNullableInteger;
    currentDealWorkflowStatusId?: number | undefined;
    nextDealWorkflowStatusId?: number | undefined;
    termInMonthsOverride: IUpdatableOfNullableInteger;
    ongoingWorkflowActionId: IUpdatableOfNullableInteger;
    ongoingWorkflowActionNote: string;
    completedActionId?: number | undefined;
    executed: boolean;
    executionDate: IUpdatableOfNullableDateTimeOffset;
    creationDate: moment.Moment;
    isExecutionStatus: boolean;
    submissionDate?: moment.Moment | undefined;
    submissionUserId?: number | undefined;
    delegatedAuthorityUserId: IUpdatableOfNullableInteger;
    delegatedAuthorityUserName: string;
    dealWorkflowStatuses: DealWorkflowStatusDto[];
    possibleAssignments: IDealWorkflowAssignmentDto[];
    items: ILazyLoadedDataOfListOfDealItemDto;
    notes: ILazyLoadedDataOfListOfDealNoteDto;
    attachments: ILazyLoadedDataOfListOfDealAttachmentDto;
}

export class DealWorkflowStatusDto extends UpdatableListItemDto implements IDealWorkflowStatusDto {
    workflowStatusId!: number;
    workflowStatusName!: string;
    assigneeUserId?: number | undefined;
    assigneeUserName!: string;
    assigneeWorkflowRoleId!: UpdatableOfNullableInteger;
    assigneeWorkflowRoleName!: string;
    assignmentType!: WorkflowAssignmentTypeEnum;
    dateTimeConfirmed?: moment.Moment | undefined;
    dateTimeCreated?: moment.Moment | undefined;
    initiatedByUserName!: string;
    allowsDealExecution!: boolean;
    tasks!: DealWorkflowTaskDto[];

    constructor(data?: IDealWorkflowStatusDto) {
        super(data);
        if (data) {
            this.assigneeWorkflowRoleId = data.assigneeWorkflowRoleId && !(<any>data.assigneeWorkflowRoleId).toJSON ? new UpdatableOfNullableInteger(data.assigneeWorkflowRoleId) : <UpdatableOfNullableInteger>this.assigneeWorkflowRoleId; 
        }
        if (!data) {
            this.assigneeWorkflowRoleId = new UpdatableOfNullableInteger();
            this.tasks = [];
        }
        makeObservable(this, {
            workflowStatusId: observable,
            workflowStatusName: observable,
            assigneeUserId: observable,
            assigneeUserName: observable,
            assigneeWorkflowRoleId: observable,
            assigneeWorkflowRoleName: observable,
            assignmentType: observable,
            dateTimeConfirmed: observable,
            dateTimeCreated: observable,
            initiatedByUserName: observable,
            allowsDealExecution: observable,
            tasks: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.workflowStatusId = _data["workflowStatusId"];
            this.workflowStatusName = _data["workflowStatusName"];
            this.assigneeUserId = _data["assigneeUserId"];
            this.assigneeUserName = _data["assigneeUserName"];
            this.assigneeWorkflowRoleId = _data["assigneeWorkflowRoleId"] ? UpdatableOfNullableInteger.fromJS(_data["assigneeWorkflowRoleId"]) : new UpdatableOfNullableInteger();
            this.assigneeWorkflowRoleName = _data["assigneeWorkflowRoleName"];
            this.assignmentType = _data["assignmentType"];
            this.dateTimeConfirmed = _data["dateTimeConfirmed"] ? moment.parseZone(_data["dateTimeConfirmed"].toString()) : <any>undefined;
            this.dateTimeCreated = _data["dateTimeCreated"] ? moment.parseZone(_data["dateTimeCreated"].toString()) : <any>undefined;
            this.initiatedByUserName = _data["initiatedByUserName"];
            this.allowsDealExecution = _data["allowsDealExecution"];
            if (Array.isArray(_data["tasks"])) {
                this.tasks = [] as any;
                for (let item of _data["tasks"])
                    this.tasks!.push(DealWorkflowTaskDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DealWorkflowStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealWorkflowStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowStatusId"] = this.workflowStatusId;
        data["workflowStatusName"] = this.workflowStatusName;
        data["assigneeUserId"] = this.assigneeUserId;
        data["assigneeUserName"] = this.assigneeUserName;
        data["assigneeWorkflowRoleId"] = this.assigneeWorkflowRoleId ? this.assigneeWorkflowRoleId.toJSON() : <any>undefined;
        data["assigneeWorkflowRoleName"] = this.assigneeWorkflowRoleName;
        data["assignmentType"] = this.assignmentType;
        data["dateTimeConfirmed"] = this.dateTimeConfirmed ? this.dateTimeConfirmed.toISOString(true) : <any>undefined;
        data["dateTimeCreated"] = this.dateTimeCreated ? this.dateTimeCreated.toISOString(true) : <any>undefined;
        data["initiatedByUserName"] = this.initiatedByUserName;
        data["allowsDealExecution"] = this.allowsDealExecution;
        if (Array.isArray(this.tasks)) {
            data["tasks"] = [];
            for (let item of this.tasks)
                data["tasks"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): DealWorkflowStatusDto {
        const json = this.toJSON();
        let result = new DealWorkflowStatusDto();
        result.init(json);
        return result;
    }
}

export interface IDealWorkflowStatusDto extends IUpdatableListItemDto {
    workflowStatusId: number;
    workflowStatusName: string;
    assigneeUserId?: number | undefined;
    assigneeUserName: string;
    assigneeWorkflowRoleId: IUpdatableOfNullableInteger;
    assigneeWorkflowRoleName: string;
    assignmentType: WorkflowAssignmentTypeEnum;
    dateTimeConfirmed?: moment.Moment | undefined;
    dateTimeCreated?: moment.Moment | undefined;
    initiatedByUserName: string;
    allowsDealExecution: boolean;
    tasks: DealWorkflowTaskDto[];
}

export enum WorkflowAssignmentTypeEnum {
    DealTrader = 1,
    PredefinedApprovalLevel = 3,
    ApprovalLevelSelectionEqualHigher = 4,
}

export class DealWorkflowTaskDto extends UpdatableListItemDto implements IDealWorkflowTaskDto {
    precedingAnswerId?: number | undefined;
    workflowTaskId!: number;
    workflowTaskDescription!: UpdatableOfString;
    type!: WorkflowTaskTypeEnum;
    mandatory!: boolean;
    workflowTaskAnswerId!: UpdatableOfNullableInteger;
    possibleAnswers!: WorkflowTaskAnswerReadDto[];
    workflowTaskAnswerText!: UpdatableOfString;
    textInformation!: UpdatableOfString;
    dateInformation!: UpdatableOfNullableDateTimeOffset;
    numberInformation!: UpdatableOfNullableDecimal;
    done!: UpdatableOfBoolean;

    constructor(data?: IDealWorkflowTaskDto) {
        super(data);
        if (data) {
            this.workflowTaskDescription = data.workflowTaskDescription && !(<any>data.workflowTaskDescription).toJSON ? new UpdatableOfString(data.workflowTaskDescription) : <UpdatableOfString>this.workflowTaskDescription; 
            this.workflowTaskAnswerId = data.workflowTaskAnswerId && !(<any>data.workflowTaskAnswerId).toJSON ? new UpdatableOfNullableInteger(data.workflowTaskAnswerId) : <UpdatableOfNullableInteger>this.workflowTaskAnswerId; 
            if (data.possibleAnswers) {
                this.possibleAnswers = [];
                for (let i = 0; i < data.possibleAnswers.length; i++) {
                    let item = data.possibleAnswers[i];
                    this.possibleAnswers[i] = item && !(<any>item).toJSON ? new WorkflowTaskAnswerReadDto(item) : <WorkflowTaskAnswerReadDto>item;
                }
            }
            this.workflowTaskAnswerText = data.workflowTaskAnswerText && !(<any>data.workflowTaskAnswerText).toJSON ? new UpdatableOfString(data.workflowTaskAnswerText) : <UpdatableOfString>this.workflowTaskAnswerText; 
            this.textInformation = data.textInformation && !(<any>data.textInformation).toJSON ? new UpdatableOfString(data.textInformation) : <UpdatableOfString>this.textInformation; 
            this.dateInformation = data.dateInformation && !(<any>data.dateInformation).toJSON ? new UpdatableOfNullableDateTimeOffset(data.dateInformation) : <UpdatableOfNullableDateTimeOffset>this.dateInformation; 
            this.numberInformation = data.numberInformation && !(<any>data.numberInformation).toJSON ? new UpdatableOfNullableDecimal(data.numberInformation) : <UpdatableOfNullableDecimal>this.numberInformation; 
            this.done = data.done && !(<any>data.done).toJSON ? new UpdatableOfBoolean(data.done) : <UpdatableOfBoolean>this.done; 
        }
        if (!data) {
            this.workflowTaskDescription = new UpdatableOfString();
            this.workflowTaskAnswerId = new UpdatableOfNullableInteger();
            this.possibleAnswers = [];
            this.workflowTaskAnswerText = new UpdatableOfString();
            this.textInformation = new UpdatableOfString();
            this.dateInformation = new UpdatableOfNullableDateTimeOffset();
            this.numberInformation = new UpdatableOfNullableDecimal();
            this.done = new UpdatableOfBoolean();
        }
        makeObservable(this, {
            precedingAnswerId: observable,
            workflowTaskId: observable,
            workflowTaskDescription: observable,
            type: observable,
            mandatory: observable,
            workflowTaskAnswerId: observable,
            possibleAnswers: observable,
            workflowTaskAnswerText: observable,
            textInformation: observable,
            dateInformation: observable,
            numberInformation: observable,
            done: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.precedingAnswerId = _data["precedingAnswerId"];
            this.workflowTaskId = _data["workflowTaskId"];
            this.workflowTaskDescription = _data["workflowTaskDescription"] ? UpdatableOfString.fromJS(_data["workflowTaskDescription"]) : new UpdatableOfString();
            this.type = _data["type"];
            this.mandatory = _data["mandatory"];
            this.workflowTaskAnswerId = _data["workflowTaskAnswerId"] ? UpdatableOfNullableInteger.fromJS(_data["workflowTaskAnswerId"]) : new UpdatableOfNullableInteger();
            if (Array.isArray(_data["possibleAnswers"])) {
                this.possibleAnswers = [] as any;
                for (let item of _data["possibleAnswers"])
                    this.possibleAnswers!.push(WorkflowTaskAnswerReadDto.fromJS(item));
            }
            this.workflowTaskAnswerText = _data["workflowTaskAnswerText"] ? UpdatableOfString.fromJS(_data["workflowTaskAnswerText"]) : new UpdatableOfString();
            this.textInformation = _data["textInformation"] ? UpdatableOfString.fromJS(_data["textInformation"]) : new UpdatableOfString();
            this.dateInformation = _data["dateInformation"] ? UpdatableOfNullableDateTimeOffset.fromJS(_data["dateInformation"]) : new UpdatableOfNullableDateTimeOffset();
            this.numberInformation = _data["numberInformation"] ? UpdatableOfNullableDecimal.fromJS(_data["numberInformation"]) : new UpdatableOfNullableDecimal();
            this.done = _data["done"] ? UpdatableOfBoolean.fromJS(_data["done"]) : new UpdatableOfBoolean();
        }
    }

    static fromJS(data: any): DealWorkflowTaskDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealWorkflowTaskDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["precedingAnswerId"] = this.precedingAnswerId;
        data["workflowTaskId"] = this.workflowTaskId;
        data["workflowTaskDescription"] = this.workflowTaskDescription ? this.workflowTaskDescription.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["mandatory"] = this.mandatory;
        data["workflowTaskAnswerId"] = this.workflowTaskAnswerId ? this.workflowTaskAnswerId.toJSON() : <any>undefined;
        if (Array.isArray(this.possibleAnswers)) {
            data["possibleAnswers"] = [];
            for (let item of this.possibleAnswers)
                data["possibleAnswers"].push(item.toJSON());
        }
        data["workflowTaskAnswerText"] = this.workflowTaskAnswerText ? this.workflowTaskAnswerText.toJSON() : <any>undefined;
        data["textInformation"] = this.textInformation ? this.textInformation.toJSON() : <any>undefined;
        data["dateInformation"] = this.dateInformation ? this.dateInformation.toJSON() : <any>undefined;
        data["numberInformation"] = this.numberInformation ? this.numberInformation.toJSON() : <any>undefined;
        data["done"] = this.done ? this.done.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }

    clone(): DealWorkflowTaskDto {
        const json = this.toJSON();
        let result = new DealWorkflowTaskDto();
        result.init(json);
        return result;
    }
}

export interface IDealWorkflowTaskDto extends IUpdatableListItemDto {
    precedingAnswerId?: number | undefined;
    workflowTaskId: number;
    workflowTaskDescription: IUpdatableOfString;
    type: WorkflowTaskTypeEnum;
    mandatory: boolean;
    workflowTaskAnswerId: IUpdatableOfNullableInteger;
    possibleAnswers: IWorkflowTaskAnswerReadDto[];
    workflowTaskAnswerText: IUpdatableOfString;
    textInformation: IUpdatableOfString;
    dateInformation: IUpdatableOfNullableDateTimeOffset;
    numberInformation: IUpdatableOfNullableDecimal;
    done: IUpdatableOfBoolean;
}

export enum WorkflowTaskTypeEnum {
    SimpleCheck = 1,
    AnswerToQuestion = 2,
    EnterTextInformation = 3,
    EnterDateInformation = 4,
    EnterDateTimeInformation = 5,
    EnterMonthAndYearInformation = 6,
    EnterNumberInformation = 7,
    EnterMultipleInformation = 8,
    ExpiryDateCheck = 9,
    DealExecutedCheck = 10,
    DealNotExecutedCheck = 11,
    HasItems = 12,
    CreatedNoteDuringStatus = 13,
    AttachedDocumentDuringStatus = 14,
    DealWithinRespectiveAuthorityLevels = 15,
}

export class WorkflowTaskAnswerReadDto implements IWorkflowTaskAnswerReadDto {
    id!: number;
    description!: string;
    attachmentTypeToVerifyId?: number | undefined;
    alternateWorkflowActionId?: number | undefined;
    subsequentWorkflowTaskIds!: number[];
    answerType?: WorkflowTaskAnswerTypeEnum | undefined;

    constructor(data?: IWorkflowTaskAnswerReadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.subsequentWorkflowTaskIds = [];
        }
        makeObservable(this, {
            id: observable,
            description: observable,
            attachmentTypeToVerifyId: observable,
            alternateWorkflowActionId: observable,
            subsequentWorkflowTaskIds: observable,
            answerType: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.attachmentTypeToVerifyId = _data["attachmentTypeToVerifyId"];
            this.alternateWorkflowActionId = _data["alternateWorkflowActionId"];
            if (Array.isArray(_data["subsequentWorkflowTaskIds"])) {
                this.subsequentWorkflowTaskIds = [] as any;
                for (let item of _data["subsequentWorkflowTaskIds"])
                    this.subsequentWorkflowTaskIds!.push(item);
            }
            this.answerType = _data["answerType"];
        }
    }

    static fromJS(data: any): WorkflowTaskAnswerReadDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTaskAnswerReadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["attachmentTypeToVerifyId"] = this.attachmentTypeToVerifyId;
        data["alternateWorkflowActionId"] = this.alternateWorkflowActionId;
        if (Array.isArray(this.subsequentWorkflowTaskIds)) {
            data["subsequentWorkflowTaskIds"] = [];
            for (let item of this.subsequentWorkflowTaskIds)
                data["subsequentWorkflowTaskIds"].push(item);
        }
        data["answerType"] = this.answerType;
        return data; 
    }

    clone(): WorkflowTaskAnswerReadDto {
        const json = this.toJSON();
        let result = new WorkflowTaskAnswerReadDto();
        result.init(json);
        return result;
    }
}

export interface IWorkflowTaskAnswerReadDto {
    id: number;
    description: string;
    attachmentTypeToVerifyId?: number | undefined;
    alternateWorkflowActionId?: number | undefined;
    subsequentWorkflowTaskIds: number[];
    answerType?: WorkflowTaskAnswerTypeEnum | undefined;
}

export enum WorkflowTaskAnswerTypeEnum {
    Yes = 1,
    No = 2,
    Other = 3,
}

export class UpdatableOfNullableDecimal implements IUpdatableOfNullableDecimal {
    updated!: boolean;
    value?: number | undefined;

    constructor(data?: IUpdatableOfNullableDecimal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            updated: observable,
            value: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.updated = _data["updated"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdatableOfNullableDecimal {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatableOfNullableDecimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["updated"] = this.updated;
        data["value"] = this.value;
        return data; 
    }

    clone(): UpdatableOfNullableDecimal {
        const json = this.toJSON();
        let result = new UpdatableOfNullableDecimal();
        result.init(json);
        return result;
    }
}

export interface IUpdatableOfNullableDecimal {
    updated: boolean;
    value?: number | undefined;
}

export class DealWorkflowAssignmentDto implements IDealWorkflowAssignmentDto {
    workflowRoleId!: number;
    workflowRoleName!: string;
    enabledForSelection!: boolean;
    meetsTradingPolicy!: boolean;
    approvalLevel?: number | undefined;
    isTraderWorkflowLevel!: boolean;
    assessments!: TraderAuthorityPolicyAssessment[];

    constructor(data?: IDealWorkflowAssignmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.assessments) {
                this.assessments = [];
                for (let i = 0; i < data.assessments.length; i++) {
                    let item = data.assessments[i];
                    this.assessments[i] = item && !(<any>item).toJSON ? new TraderAuthorityPolicyAssessment(item) : <TraderAuthorityPolicyAssessment>item;
                }
            }
        }
        if (!data) {
            this.assessments = [];
        }
        makeObservable(this, {
            workflowRoleId: observable,
            workflowRoleName: observable,
            enabledForSelection: observable,
            meetsTradingPolicy: observable,
            approvalLevel: observable,
            isTraderWorkflowLevel: observable,
            assessments: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.workflowRoleId = _data["workflowRoleId"];
            this.workflowRoleName = _data["workflowRoleName"];
            this.enabledForSelection = _data["enabledForSelection"];
            this.meetsTradingPolicy = _data["meetsTradingPolicy"];
            this.approvalLevel = _data["approvalLevel"];
            this.isTraderWorkflowLevel = _data["isTraderWorkflowLevel"];
            if (Array.isArray(_data["assessments"])) {
                this.assessments = [] as any;
                for (let item of _data["assessments"])
                    this.assessments!.push(TraderAuthorityPolicyAssessment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DealWorkflowAssignmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealWorkflowAssignmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowRoleId"] = this.workflowRoleId;
        data["workflowRoleName"] = this.workflowRoleName;
        data["enabledForSelection"] = this.enabledForSelection;
        data["meetsTradingPolicy"] = this.meetsTradingPolicy;
        data["approvalLevel"] = this.approvalLevel;
        data["isTraderWorkflowLevel"] = this.isTraderWorkflowLevel;
        if (Array.isArray(this.assessments)) {
            data["assessments"] = [];
            for (let item of this.assessments)
                data["assessments"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DealWorkflowAssignmentDto {
        const json = this.toJSON();
        let result = new DealWorkflowAssignmentDto();
        result.init(json);
        return result;
    }
}

export interface IDealWorkflowAssignmentDto {
    workflowRoleId: number;
    workflowRoleName: string;
    enabledForSelection: boolean;
    meetsTradingPolicy: boolean;
    approvalLevel?: number | undefined;
    isTraderWorkflowLevel: boolean;
    assessments: ITraderAuthorityPolicyAssessment[];
}

export class TraderAuthorityPolicyAssessment implements ITraderAuthorityPolicyAssessment {
    policyMet!: boolean;
    assessmentRows!: TraderAuthorityPolicyAssessmentRow[];

    constructor(data?: ITraderAuthorityPolicyAssessment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.assessmentRows) {
                this.assessmentRows = [];
                for (let i = 0; i < data.assessmentRows.length; i++) {
                    let item = data.assessmentRows[i];
                    this.assessmentRows[i] = item && !(<any>item).toJSON ? new TraderAuthorityPolicyAssessmentRow(item) : <TraderAuthorityPolicyAssessmentRow>item;
                }
            }
        }
        if (!data) {
            this.assessmentRows = [];
        }
        makeObservable(this, {
            policyMet: observable,
            assessmentRows: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.policyMet = _data["policyMet"];
            if (Array.isArray(_data["assessmentRows"])) {
                this.assessmentRows = [] as any;
                for (let item of _data["assessmentRows"])
                    this.assessmentRows!.push(TraderAuthorityPolicyAssessmentRow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TraderAuthorityPolicyAssessment {
        data = typeof data === 'object' ? data : {};
        let result = new TraderAuthorityPolicyAssessment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["policyMet"] = this.policyMet;
        if (Array.isArray(this.assessmentRows)) {
            data["assessmentRows"] = [];
            for (let item of this.assessmentRows)
                data["assessmentRows"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TraderAuthorityPolicyAssessment {
        const json = this.toJSON();
        let result = new TraderAuthorityPolicyAssessment();
        result.init(json);
        return result;
    }
}

export interface ITraderAuthorityPolicyAssessment {
    policyMet: boolean;
    assessmentRows: ITraderAuthorityPolicyAssessmentRow[];
}

export class TraderAuthorityPolicyAssessmentRow implements ITraderAuthorityPolicyAssessmentRow {
    description!: string;
    detailedDescription!: string;
    policyValue!: string;
    dealValue!: string;
    criteriaMet!: boolean;
    isTermCriteria!: boolean;

    constructor(data?: ITraderAuthorityPolicyAssessmentRow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            description: observable,
            detailedDescription: observable,
            policyValue: observable,
            dealValue: observable,
            criteriaMet: observable,
            isTermCriteria: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.detailedDescription = _data["detailedDescription"];
            this.policyValue = _data["policyValue"];
            this.dealValue = _data["dealValue"];
            this.criteriaMet = _data["criteriaMet"];
            this.isTermCriteria = _data["isTermCriteria"];
        }
    }

    static fromJS(data: any): TraderAuthorityPolicyAssessmentRow {
        data = typeof data === 'object' ? data : {};
        let result = new TraderAuthorityPolicyAssessmentRow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["detailedDescription"] = this.detailedDescription;
        data["policyValue"] = this.policyValue;
        data["dealValue"] = this.dealValue;
        data["criteriaMet"] = this.criteriaMet;
        data["isTermCriteria"] = this.isTermCriteria;
        return data; 
    }

    clone(): TraderAuthorityPolicyAssessmentRow {
        const json = this.toJSON();
        let result = new TraderAuthorityPolicyAssessmentRow();
        result.init(json);
        return result;
    }
}

export interface ITraderAuthorityPolicyAssessmentRow {
    description: string;
    detailedDescription: string;
    policyValue: string;
    dealValue: string;
    criteriaMet: boolean;
    isTermCriteria: boolean;
}

export class LazyLoadedDataOfListOfDealItemDto implements ILazyLoadedDataOfListOfDealItemDto {
    data!: DealItemDto[];
    state!: LazyLoadedDataStateEnum;

    constructor(data?: ILazyLoadedDataOfListOfDealItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
        makeObservable(this, {
            data: observable,
            state: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(DealItemDto.fromJS(item));
            }
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): LazyLoadedDataOfListOfDealItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LazyLoadedDataOfListOfDealItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["state"] = this.state;
        return data; 
    }

    clone(): LazyLoadedDataOfListOfDealItemDto {
        const json = this.toJSON();
        let result = new LazyLoadedDataOfListOfDealItemDto();
        result.init(json);
        return result;
    }
}

export interface ILazyLoadedDataOfListOfDealItemDto {
    data: DealItemDto[];
    state: LazyLoadedDataStateEnum;
}

export class DealItemDto extends UpdatableListItemDto implements IDealItemDto {
    order!: number;
    productId!: UpdatableOfNullableInteger;
    productDescription!: string;
    position!: UpdatableOfNullablePositionEnum;
    dayType!: UpdatableOfNullableDayTypeEnum;
    startDate!: UpdatableOfNullableDateTimeOffset;
    halfHourTradingPeriodStart!: UpdatableOfNullableInteger;
    endDate!: UpdatableOfNullableDateTimeOffset;
    halfHourTradingPeriodEnd!: UpdatableOfNullableInteger;
    quantity!: UpdatableOfNullableDecimal;
    minQuantity!: UpdatableOfNullableDecimal;
    maxQuantity!: UpdatableOfNullableDecimal;
    price!: UpdatableOfNullableDecimal;
    criteria!: UpdatableOfString;
    originalItemId?: number | undefined;
    executedItems!: DealExecutedItemDto[];
    executed!: boolean;
    sourceData!: DealItemSourceDataDto;

    constructor(data?: IDealItemDto) {
        super(data);
        if (data) {
            this.productId = data.productId && !(<any>data.productId).toJSON ? new UpdatableOfNullableInteger(data.productId) : <UpdatableOfNullableInteger>this.productId; 
            this.position = data.position && !(<any>data.position).toJSON ? new UpdatableOfNullablePositionEnum(data.position) : <UpdatableOfNullablePositionEnum>this.position; 
            this.dayType = data.dayType && !(<any>data.dayType).toJSON ? new UpdatableOfNullableDayTypeEnum(data.dayType) : <UpdatableOfNullableDayTypeEnum>this.dayType; 
            this.startDate = data.startDate && !(<any>data.startDate).toJSON ? new UpdatableOfNullableDateTimeOffset(data.startDate) : <UpdatableOfNullableDateTimeOffset>this.startDate; 
            this.halfHourTradingPeriodStart = data.halfHourTradingPeriodStart && !(<any>data.halfHourTradingPeriodStart).toJSON ? new UpdatableOfNullableInteger(data.halfHourTradingPeriodStart) : <UpdatableOfNullableInteger>this.halfHourTradingPeriodStart; 
            this.endDate = data.endDate && !(<any>data.endDate).toJSON ? new UpdatableOfNullableDateTimeOffset(data.endDate) : <UpdatableOfNullableDateTimeOffset>this.endDate; 
            this.halfHourTradingPeriodEnd = data.halfHourTradingPeriodEnd && !(<any>data.halfHourTradingPeriodEnd).toJSON ? new UpdatableOfNullableInteger(data.halfHourTradingPeriodEnd) : <UpdatableOfNullableInteger>this.halfHourTradingPeriodEnd; 
            this.quantity = data.quantity && !(<any>data.quantity).toJSON ? new UpdatableOfNullableDecimal(data.quantity) : <UpdatableOfNullableDecimal>this.quantity; 
            this.minQuantity = data.minQuantity && !(<any>data.minQuantity).toJSON ? new UpdatableOfNullableDecimal(data.minQuantity) : <UpdatableOfNullableDecimal>this.minQuantity; 
            this.maxQuantity = data.maxQuantity && !(<any>data.maxQuantity).toJSON ? new UpdatableOfNullableDecimal(data.maxQuantity) : <UpdatableOfNullableDecimal>this.maxQuantity; 
            this.price = data.price && !(<any>data.price).toJSON ? new UpdatableOfNullableDecimal(data.price) : <UpdatableOfNullableDecimal>this.price; 
            this.criteria = data.criteria && !(<any>data.criteria).toJSON ? new UpdatableOfString(data.criteria) : <UpdatableOfString>this.criteria; 
            this.sourceData = data.sourceData && !(<any>data.sourceData).toJSON ? new DealItemSourceDataDto(data.sourceData) : <DealItemSourceDataDto>this.sourceData; 
        }
        if (!data) {
            this.productId = new UpdatableOfNullableInteger();
            this.position = new UpdatableOfNullablePositionEnum();
            this.dayType = new UpdatableOfNullableDayTypeEnum();
            this.startDate = new UpdatableOfNullableDateTimeOffset();
            this.halfHourTradingPeriodStart = new UpdatableOfNullableInteger();
            this.endDate = new UpdatableOfNullableDateTimeOffset();
            this.halfHourTradingPeriodEnd = new UpdatableOfNullableInteger();
            this.quantity = new UpdatableOfNullableDecimal();
            this.minQuantity = new UpdatableOfNullableDecimal();
            this.maxQuantity = new UpdatableOfNullableDecimal();
            this.price = new UpdatableOfNullableDecimal();
            this.criteria = new UpdatableOfString();
            this.executedItems = [];
            this.sourceData = new DealItemSourceDataDto();
        }
        makeObservable(this, {
            order: observable,
            productId: observable,
            productDescription: observable,
            position: observable,
            dayType: observable,
            startDate: observable,
            halfHourTradingPeriodStart: observable,
            endDate: observable,
            halfHourTradingPeriodEnd: observable,
            quantity: observable,
            minQuantity: observable,
            maxQuantity: observable,
            price: observable,
            criteria: observable,
            originalItemId: observable,
            executedItems: observable,
            executed: observable,
            sourceData: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.order = _data["order"];
            this.productId = _data["productId"] ? UpdatableOfNullableInteger.fromJS(_data["productId"]) : new UpdatableOfNullableInteger();
            this.productDescription = _data["productDescription"];
            this.position = _data["position"] ? UpdatableOfNullablePositionEnum.fromJS(_data["position"]) : new UpdatableOfNullablePositionEnum();
            this.dayType = _data["dayType"] ? UpdatableOfNullableDayTypeEnum.fromJS(_data["dayType"]) : new UpdatableOfNullableDayTypeEnum();
            this.startDate = _data["startDate"] ? UpdatableOfNullableDateTimeOffset.fromJS(_data["startDate"]) : new UpdatableOfNullableDateTimeOffset();
            this.halfHourTradingPeriodStart = _data["halfHourTradingPeriodStart"] ? UpdatableOfNullableInteger.fromJS(_data["halfHourTradingPeriodStart"]) : new UpdatableOfNullableInteger();
            this.endDate = _data["endDate"] ? UpdatableOfNullableDateTimeOffset.fromJS(_data["endDate"]) : new UpdatableOfNullableDateTimeOffset();
            this.halfHourTradingPeriodEnd = _data["halfHourTradingPeriodEnd"] ? UpdatableOfNullableInteger.fromJS(_data["halfHourTradingPeriodEnd"]) : new UpdatableOfNullableInteger();
            this.quantity = _data["quantity"] ? UpdatableOfNullableDecimal.fromJS(_data["quantity"]) : new UpdatableOfNullableDecimal();
            this.minQuantity = _data["minQuantity"] ? UpdatableOfNullableDecimal.fromJS(_data["minQuantity"]) : new UpdatableOfNullableDecimal();
            this.maxQuantity = _data["maxQuantity"] ? UpdatableOfNullableDecimal.fromJS(_data["maxQuantity"]) : new UpdatableOfNullableDecimal();
            this.price = _data["price"] ? UpdatableOfNullableDecimal.fromJS(_data["price"]) : new UpdatableOfNullableDecimal();
            this.criteria = _data["criteria"] ? UpdatableOfString.fromJS(_data["criteria"]) : new UpdatableOfString();
            this.originalItemId = _data["originalItemId"];
            if (Array.isArray(_data["executedItems"])) {
                this.executedItems = [] as any;
                for (let item of _data["executedItems"])
                    this.executedItems!.push(DealExecutedItemDto.fromJS(item));
            }
            this.executed = _data["executed"];
            this.sourceData = _data["sourceData"] ? DealItemSourceDataDto.fromJS(_data["sourceData"]) : new DealItemSourceDataDto();
        }
    }

    static fromJS(data: any): DealItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["order"] = this.order;
        data["productId"] = this.productId ? this.productId.toJSON() : <any>undefined;
        data["productDescription"] = this.productDescription;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["dayType"] = this.dayType ? this.dayType.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toJSON() : <any>undefined;
        data["halfHourTradingPeriodStart"] = this.halfHourTradingPeriodStart ? this.halfHourTradingPeriodStart.toJSON() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toJSON() : <any>undefined;
        data["halfHourTradingPeriodEnd"] = this.halfHourTradingPeriodEnd ? this.halfHourTradingPeriodEnd.toJSON() : <any>undefined;
        data["quantity"] = this.quantity ? this.quantity.toJSON() : <any>undefined;
        data["minQuantity"] = this.minQuantity ? this.minQuantity.toJSON() : <any>undefined;
        data["maxQuantity"] = this.maxQuantity ? this.maxQuantity.toJSON() : <any>undefined;
        data["price"] = this.price ? this.price.toJSON() : <any>undefined;
        data["criteria"] = this.criteria ? this.criteria.toJSON() : <any>undefined;
        data["originalItemId"] = this.originalItemId;
        if (Array.isArray(this.executedItems)) {
            data["executedItems"] = [];
            for (let item of this.executedItems)
                data["executedItems"].push(item.toJSON());
        }
        data["executed"] = this.executed;
        data["sourceData"] = this.sourceData ? this.sourceData.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }

    clone(): DealItemDto {
        const json = this.toJSON();
        let result = new DealItemDto();
        result.init(json);
        return result;
    }
}

export interface IDealItemDto extends IUpdatableListItemDto {
    order: number;
    productId: IUpdatableOfNullableInteger;
    productDescription: string;
    position: IUpdatableOfNullablePositionEnum;
    dayType: IUpdatableOfNullableDayTypeEnum;
    startDate: IUpdatableOfNullableDateTimeOffset;
    halfHourTradingPeriodStart: IUpdatableOfNullableInteger;
    endDate: IUpdatableOfNullableDateTimeOffset;
    halfHourTradingPeriodEnd: IUpdatableOfNullableInteger;
    quantity: IUpdatableOfNullableDecimal;
    minQuantity: IUpdatableOfNullableDecimal;
    maxQuantity: IUpdatableOfNullableDecimal;
    price: IUpdatableOfNullableDecimal;
    criteria: IUpdatableOfString;
    originalItemId?: number | undefined;
    executedItems: DealExecutedItemDto[];
    executed: boolean;
    sourceData: IDealItemSourceDataDto;
}

export class UpdatableOfNullablePositionEnum implements IUpdatableOfNullablePositionEnum {
    updated!: boolean;
    value?: PositionEnum | undefined;

    constructor(data?: IUpdatableOfNullablePositionEnum) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            updated: observable,
            value: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.updated = _data["updated"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdatableOfNullablePositionEnum {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatableOfNullablePositionEnum();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["updated"] = this.updated;
        data["value"] = this.value;
        return data; 
    }

    clone(): UpdatableOfNullablePositionEnum {
        const json = this.toJSON();
        let result = new UpdatableOfNullablePositionEnum();
        result.init(json);
        return result;
    }
}

export interface IUpdatableOfNullablePositionEnum {
    updated: boolean;
    value?: PositionEnum | undefined;
}

export enum PositionEnum {
    Sell = 0,
    Buy = 1,
}

export class UpdatableOfNullableDayTypeEnum implements IUpdatableOfNullableDayTypeEnum {
    updated!: boolean;
    value?: DayTypeEnum | undefined;

    constructor(data?: IUpdatableOfNullableDayTypeEnum) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            updated: observable,
            value: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.updated = _data["updated"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdatableOfNullableDayTypeEnum {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatableOfNullableDayTypeEnum();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["updated"] = this.updated;
        data["value"] = this.value;
        return data; 
    }

    clone(): UpdatableOfNullableDayTypeEnum {
        const json = this.toJSON();
        let result = new UpdatableOfNullableDayTypeEnum();
        result.init(json);
        return result;
    }
}

export interface IUpdatableOfNullableDayTypeEnum {
    updated: boolean;
    value?: DayTypeEnum | undefined;
}

export enum DayTypeEnum {
    AllDays = 1,
    WeekDays = 2,
    WeekendDays = 3,
}

export class DealExecutedItemDto extends DealItemDto implements IDealExecutedItemDto {

    constructor(data?: IDealExecutedItemDto) {
        super(data);
        makeObservable(this, {
        })
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): DealExecutedItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealExecutedItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }

    clone(): DealExecutedItemDto {
        const json = this.toJSON();
        let result = new DealExecutedItemDto();
        result.init(json);
        return result;
    }
}

export interface IDealExecutedItemDto extends IDealItemDto {
}

export class DealItemSourceDataDto implements IDealItemSourceDataDto {
    sourceId?: number | undefined;
    type?: DealItemSourceTypeEnum | undefined;
    creationDate?: moment.Moment | undefined;

    constructor(data?: IDealItemSourceDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            sourceId: observable,
            type: observable,
            creationDate: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.sourceId = _data["sourceId"];
            this.type = _data["type"];
            this.creationDate = _data["creationDate"] ? moment.parseZone(_data["creationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DealItemSourceDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealItemSourceDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceId"] = this.sourceId;
        data["type"] = this.type;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString(true) : <any>undefined;
        return data; 
    }

    clone(): DealItemSourceDataDto {
        const json = this.toJSON();
        let result = new DealItemSourceDataDto();
        result.init(json);
        return result;
    }
}

export interface IDealItemSourceDataDto {
    sourceId?: number | undefined;
    type?: DealItemSourceTypeEnum | undefined;
    creationDate?: moment.Moment | undefined;
}

export enum DealItemSourceTypeEnum {
    Ems = 1,
    Ftr = 2,
}

export enum LazyLoadedDataStateEnum {
    NotLoaded = 0,
    Loading = 1,
    Ready = 2,
}

export class LazyLoadedDataOfListOfDealNoteDto implements ILazyLoadedDataOfListOfDealNoteDto {
    data!: DealNoteDto[];
    state!: LazyLoadedDataStateEnum;

    constructor(data?: ILazyLoadedDataOfListOfDealNoteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
        makeObservable(this, {
            data: observable,
            state: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(DealNoteDto.fromJS(item));
            }
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): LazyLoadedDataOfListOfDealNoteDto {
        data = typeof data === 'object' ? data : {};
        let result = new LazyLoadedDataOfListOfDealNoteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["state"] = this.state;
        return data; 
    }

    clone(): LazyLoadedDataOfListOfDealNoteDto {
        const json = this.toJSON();
        let result = new LazyLoadedDataOfListOfDealNoteDto();
        result.init(json);
        return result;
    }
}

export interface ILazyLoadedDataOfListOfDealNoteDto {
    data: DealNoteDto[];
    state: LazyLoadedDataStateEnum;
}

export class DealNoteDto extends UpdatableListItemDto implements IDealNoteDto {
    dealId?: number | undefined;
    noteCreatorId!: number;
    noteCreatorName!: string;
    noteContent!: UpdatableOfString;
    createdDate!: UpdatableOfDateTimeOffset;
    isLocked!: boolean;
    reminderType!: UpdatableOfNullableNoteReminderTypeEnum;
    reminderEmailAccounts!: UpdatableOfString;
    reminderDateTime!: UpdatableOfNullableDateTimeOffset;

    constructor(data?: IDealNoteDto) {
        super(data);
        if (data) {
            this.noteContent = data.noteContent && !(<any>data.noteContent).toJSON ? new UpdatableOfString(data.noteContent) : <UpdatableOfString>this.noteContent; 
            this.createdDate = data.createdDate && !(<any>data.createdDate).toJSON ? new UpdatableOfDateTimeOffset(data.createdDate) : <UpdatableOfDateTimeOffset>this.createdDate; 
            this.reminderType = data.reminderType && !(<any>data.reminderType).toJSON ? new UpdatableOfNullableNoteReminderTypeEnum(data.reminderType) : <UpdatableOfNullableNoteReminderTypeEnum>this.reminderType; 
            this.reminderEmailAccounts = data.reminderEmailAccounts && !(<any>data.reminderEmailAccounts).toJSON ? new UpdatableOfString(data.reminderEmailAccounts) : <UpdatableOfString>this.reminderEmailAccounts; 
            this.reminderDateTime = data.reminderDateTime && !(<any>data.reminderDateTime).toJSON ? new UpdatableOfNullableDateTimeOffset(data.reminderDateTime) : <UpdatableOfNullableDateTimeOffset>this.reminderDateTime; 
        }
        if (!data) {
            this.noteContent = new UpdatableOfString();
            this.createdDate = new UpdatableOfDateTimeOffset();
            this.reminderType = new UpdatableOfNullableNoteReminderTypeEnum();
            this.reminderEmailAccounts = new UpdatableOfString();
            this.reminderDateTime = new UpdatableOfNullableDateTimeOffset();
        }
        makeObservable(this, {
            dealId: observable,
            noteCreatorId: observable,
            noteCreatorName: observable,
            noteContent: observable,
            createdDate: observable,
            isLocked: observable,
            reminderType: observable,
            reminderEmailAccounts: observable,
            reminderDateTime: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.dealId = _data["dealId"];
            this.noteCreatorId = _data["noteCreatorId"];
            this.noteCreatorName = _data["noteCreatorName"];
            this.noteContent = _data["noteContent"] ? UpdatableOfString.fromJS(_data["noteContent"]) : new UpdatableOfString();
            this.createdDate = _data["createdDate"] ? UpdatableOfDateTimeOffset.fromJS(_data["createdDate"]) : new UpdatableOfDateTimeOffset();
            this.isLocked = _data["isLocked"];
            this.reminderType = _data["reminderType"] ? UpdatableOfNullableNoteReminderTypeEnum.fromJS(_data["reminderType"]) : new UpdatableOfNullableNoteReminderTypeEnum();
            this.reminderEmailAccounts = _data["reminderEmailAccounts"] ? UpdatableOfString.fromJS(_data["reminderEmailAccounts"]) : new UpdatableOfString();
            this.reminderDateTime = _data["reminderDateTime"] ? UpdatableOfNullableDateTimeOffset.fromJS(_data["reminderDateTime"]) : new UpdatableOfNullableDateTimeOffset();
        }
    }

    static fromJS(data: any): DealNoteDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealNoteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dealId"] = this.dealId;
        data["noteCreatorId"] = this.noteCreatorId;
        data["noteCreatorName"] = this.noteCreatorName;
        data["noteContent"] = this.noteContent ? this.noteContent.toJSON() : <any>undefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toJSON() : <any>undefined;
        data["isLocked"] = this.isLocked;
        data["reminderType"] = this.reminderType ? this.reminderType.toJSON() : <any>undefined;
        data["reminderEmailAccounts"] = this.reminderEmailAccounts ? this.reminderEmailAccounts.toJSON() : <any>undefined;
        data["reminderDateTime"] = this.reminderDateTime ? this.reminderDateTime.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }

    clone(): DealNoteDto {
        const json = this.toJSON();
        let result = new DealNoteDto();
        result.init(json);
        return result;
    }
}

export interface IDealNoteDto extends IUpdatableListItemDto {
    dealId?: number | undefined;
    noteCreatorId: number;
    noteCreatorName: string;
    noteContent: IUpdatableOfString;
    createdDate: IUpdatableOfDateTimeOffset;
    isLocked: boolean;
    reminderType: IUpdatableOfNullableNoteReminderTypeEnum;
    reminderEmailAccounts: IUpdatableOfString;
    reminderDateTime: IUpdatableOfNullableDateTimeOffset;
}

export class UpdatableOfDateTimeOffset implements IUpdatableOfDateTimeOffset {
    updated!: boolean;
    value!: moment.Moment;

    constructor(data?: IUpdatableOfDateTimeOffset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            updated: observable,
            value: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.updated = _data["updated"];
            this.value = _data["value"] ? moment.parseZone(_data["value"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdatableOfDateTimeOffset {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatableOfDateTimeOffset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["updated"] = this.updated;
        data["value"] = this.value ? this.value.toISOString(true) : <any>undefined;
        return data; 
    }

    clone(): UpdatableOfDateTimeOffset {
        const json = this.toJSON();
        let result = new UpdatableOfDateTimeOffset();
        result.init(json);
        return result;
    }
}

export interface IUpdatableOfDateTimeOffset {
    updated: boolean;
    value: moment.Moment;
}

export class UpdatableOfNullableNoteReminderTypeEnum implements IUpdatableOfNullableNoteReminderTypeEnum {
    updated!: boolean;
    value?: NoteReminderTypeEnum | undefined;

    constructor(data?: IUpdatableOfNullableNoteReminderTypeEnum) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            updated: observable,
            value: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.updated = _data["updated"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdatableOfNullableNoteReminderTypeEnum {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatableOfNullableNoteReminderTypeEnum();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["updated"] = this.updated;
        data["value"] = this.value;
        return data; 
    }

    clone(): UpdatableOfNullableNoteReminderTypeEnum {
        const json = this.toJSON();
        let result = new UpdatableOfNullableNoteReminderTypeEnum();
        result.init(json);
        return result;
    }
}

export interface IUpdatableOfNullableNoteReminderTypeEnum {
    updated: boolean;
    value?: NoteReminderTypeEnum | undefined;
}

export enum NoteReminderTypeEnum {
    Me = 1,
    MyRole = 2,
    Emails = 3,
}

export class LazyLoadedDataOfListOfDealAttachmentDto implements ILazyLoadedDataOfListOfDealAttachmentDto {
    data!: DealAttachmentDto[];
    state!: LazyLoadedDataStateEnum;

    constructor(data?: ILazyLoadedDataOfListOfDealAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
        makeObservable(this, {
            data: observable,
            state: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(DealAttachmentDto.fromJS(item));
            }
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): LazyLoadedDataOfListOfDealAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new LazyLoadedDataOfListOfDealAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["state"] = this.state;
        return data; 
    }

    clone(): LazyLoadedDataOfListOfDealAttachmentDto {
        const json = this.toJSON();
        let result = new LazyLoadedDataOfListOfDealAttachmentDto();
        result.init(json);
        return result;
    }
}

export interface ILazyLoadedDataOfListOfDealAttachmentDto {
    data: DealAttachmentDto[];
    state: LazyLoadedDataStateEnum;
}

export class DealAttachmentDto extends UpdatableListItemDto implements IDealAttachmentDto {
    attachmentTypeId!: UpdatableOfNullableInteger;
    attachmentTypeOtherText!: UpdatableOfString;
    linkType?: DealAttachmentLinkType | undefined;
    versions!: DealAttachmentVersionDto[];

    constructor(data?: IDealAttachmentDto) {
        super(data);
        if (data) {
            this.attachmentTypeId = data.attachmentTypeId && !(<any>data.attachmentTypeId).toJSON ? new UpdatableOfNullableInteger(data.attachmentTypeId) : <UpdatableOfNullableInteger>this.attachmentTypeId; 
            this.attachmentTypeOtherText = data.attachmentTypeOtherText && !(<any>data.attachmentTypeOtherText).toJSON ? new UpdatableOfString(data.attachmentTypeOtherText) : <UpdatableOfString>this.attachmentTypeOtherText; 
        }
        if (!data) {
            this.attachmentTypeId = new UpdatableOfNullableInteger();
            this.attachmentTypeOtherText = new UpdatableOfString();
            this.versions = [];
        }
        makeObservable(this, {
            attachmentTypeId: observable,
            attachmentTypeOtherText: observable,
            linkType: observable,
            versions: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.attachmentTypeId = _data["attachmentTypeId"] ? UpdatableOfNullableInteger.fromJS(_data["attachmentTypeId"]) : new UpdatableOfNullableInteger();
            this.attachmentTypeOtherText = _data["attachmentTypeOtherText"] ? UpdatableOfString.fromJS(_data["attachmentTypeOtherText"]) : new UpdatableOfString();
            this.linkType = _data["linkType"];
            if (Array.isArray(_data["versions"])) {
                this.versions = [] as any;
                for (let item of _data["versions"])
                    this.versions!.push(DealAttachmentVersionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DealAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attachmentTypeId"] = this.attachmentTypeId ? this.attachmentTypeId.toJSON() : <any>undefined;
        data["attachmentTypeOtherText"] = this.attachmentTypeOtherText ? this.attachmentTypeOtherText.toJSON() : <any>undefined;
        data["linkType"] = this.linkType;
        if (Array.isArray(this.versions)) {
            data["versions"] = [];
            for (let item of this.versions)
                data["versions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): DealAttachmentDto {
        const json = this.toJSON();
        let result = new DealAttachmentDto();
        result.init(json);
        return result;
    }
}

export interface IDealAttachmentDto extends IUpdatableListItemDto {
    attachmentTypeId: IUpdatableOfNullableInteger;
    attachmentTypeOtherText: IUpdatableOfString;
    linkType?: DealAttachmentLinkType | undefined;
    versions: DealAttachmentVersionDto[];
}

export enum DealAttachmentLinkType {
    DelegatedTradingAuthorityEvidence = 1,
}

export class DealAttachmentVersionDto extends UpdatableListItemDto implements IDealAttachmentVersionDto {
    fileName!: string;
    fileExtension!: string;
    fileBase64!: string;
    fileSizeInBytes!: number;
    createdDate!: moment.Moment;
    creationUserId!: number;
    creationUserName!: string;
    isLocked!: boolean;

    constructor(data?: IDealAttachmentVersionDto) {
        super(data);
        makeObservable(this, {
            fileName: observable,
            fileExtension: observable,
            fileBase64: observable,
            fileSizeInBytes: observable,
            createdDate: observable,
            creationUserId: observable,
            creationUserName: observable,
            isLocked: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileExtension = _data["fileExtension"];
            this.fileBase64 = _data["fileBase64"];
            this.fileSizeInBytes = _data["fileSizeInBytes"];
            this.createdDate = _data["createdDate"] ? moment.parseZone(_data["createdDate"].toString()) : <any>undefined;
            this.creationUserId = _data["creationUserId"];
            this.creationUserName = _data["creationUserName"];
            this.isLocked = _data["isLocked"];
        }
    }

    static fromJS(data: any): DealAttachmentVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealAttachmentVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileExtension"] = this.fileExtension;
        data["fileBase64"] = this.fileBase64;
        data["fileSizeInBytes"] = this.fileSizeInBytes;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString(true) : <any>undefined;
        data["creationUserId"] = this.creationUserId;
        data["creationUserName"] = this.creationUserName;
        data["isLocked"] = this.isLocked;
        super.toJSON(data);
        return data; 
    }

    clone(): DealAttachmentVersionDto {
        const json = this.toJSON();
        let result = new DealAttachmentVersionDto();
        result.init(json);
        return result;
    }
}

export interface IDealAttachmentVersionDto extends IUpdatableListItemDto {
    fileName: string;
    fileExtension: string;
    fileBase64: string;
    fileSizeInBytes: number;
    createdDate: moment.Moment;
    creationUserId: number;
    creationUserName: string;
    isLocked: boolean;
}

export class DealPostResponse implements IDealPostResponse {
    dealId!: number;
    dealNumber!: string;
    warningMessages!: string[];

    constructor(data?: IDealPostResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.warningMessages = [];
        }
        makeObservable(this, {
            dealId: observable,
            dealNumber: observable,
            warningMessages: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.dealId = _data["dealId"];
            this.dealNumber = _data["dealNumber"];
            if (Array.isArray(_data["warningMessages"])) {
                this.warningMessages = [] as any;
                for (let item of _data["warningMessages"])
                    this.warningMessages!.push(item);
            }
        }
    }

    static fromJS(data: any): DealPostResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DealPostResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dealId"] = this.dealId;
        data["dealNumber"] = this.dealNumber;
        if (Array.isArray(this.warningMessages)) {
            data["warningMessages"] = [];
            for (let item of this.warningMessages)
                data["warningMessages"].push(item);
        }
        return data; 
    }

    clone(): DealPostResponse {
        const json = this.toJSON();
        let result = new DealPostResponse();
        result.init(json);
        return result;
    }
}

export interface IDealPostResponse {
    dealId: number;
    dealNumber: string;
    warningMessages: string[];
}

export class DealAssignInfoResponse implements IDealAssignInfoResponse {
    assignedToSelf!: boolean;
    assignedToUsersRole!: boolean;
    assignedToUserDescription!: string;
    assignedToUserId?: number | undefined;
    revertBackInfo!: DealAssignRevertBackInfoResponse;

    constructor(data?: IDealAssignInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.revertBackInfo = data.revertBackInfo && !(<any>data.revertBackInfo).toJSON ? new DealAssignRevertBackInfoResponse(data.revertBackInfo) : <DealAssignRevertBackInfoResponse>this.revertBackInfo; 
        }
        if (!data) {
            this.revertBackInfo = new DealAssignRevertBackInfoResponse();
        }
        makeObservable(this, {
            assignedToSelf: observable,
            assignedToUsersRole: observable,
            assignedToUserDescription: observable,
            assignedToUserId: observable,
            revertBackInfo: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.assignedToSelf = _data["assignedToSelf"];
            this.assignedToUsersRole = _data["assignedToUsersRole"];
            this.assignedToUserDescription = _data["assignedToUserDescription"];
            this.assignedToUserId = _data["assignedToUserId"];
            this.revertBackInfo = _data["revertBackInfo"] ? DealAssignRevertBackInfoResponse.fromJS(_data["revertBackInfo"]) : new DealAssignRevertBackInfoResponse();
        }
    }

    static fromJS(data: any): DealAssignInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DealAssignInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assignedToSelf"] = this.assignedToSelf;
        data["assignedToUsersRole"] = this.assignedToUsersRole;
        data["assignedToUserDescription"] = this.assignedToUserDescription;
        data["assignedToUserId"] = this.assignedToUserId;
        data["revertBackInfo"] = this.revertBackInfo ? this.revertBackInfo.toJSON() : <any>undefined;
        return data; 
    }

    clone(): DealAssignInfoResponse {
        const json = this.toJSON();
        let result = new DealAssignInfoResponse();
        result.init(json);
        return result;
    }
}

export interface IDealAssignInfoResponse {
    assignedToSelf: boolean;
    assignedToUsersRole: boolean;
    assignedToUserDescription: string;
    assignedToUserId?: number | undefined;
    revertBackInfo: IDealAssignRevertBackInfoResponse;
}

export class DealAssignRevertBackInfoResponse implements IDealAssignRevertBackInfoResponse {
    canRevertStatusBack!: boolean;
    currentDealWorkflowStatusId!: number;
    currentDealWorkflowStatusName!: string;
    previousWorkflowStatusId!: number;
    previousDealWorkflowStatusName!: string;
    precedingWorkflowActionName!: string;
    currentWorkflowRoleName!: string;

    constructor(data?: IDealAssignRevertBackInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            canRevertStatusBack: observable,
            currentDealWorkflowStatusId: observable,
            currentDealWorkflowStatusName: observable,
            previousWorkflowStatusId: observable,
            previousDealWorkflowStatusName: observable,
            precedingWorkflowActionName: observable,
            currentWorkflowRoleName: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.canRevertStatusBack = _data["canRevertStatusBack"];
            this.currentDealWorkflowStatusId = _data["currentDealWorkflowStatusId"];
            this.currentDealWorkflowStatusName = _data["currentDealWorkflowStatusName"];
            this.previousWorkflowStatusId = _data["previousWorkflowStatusId"];
            this.previousDealWorkflowStatusName = _data["previousDealWorkflowStatusName"];
            this.precedingWorkflowActionName = _data["precedingWorkflowActionName"];
            this.currentWorkflowRoleName = _data["currentWorkflowRoleName"];
        }
    }

    static fromJS(data: any): DealAssignRevertBackInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DealAssignRevertBackInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canRevertStatusBack"] = this.canRevertStatusBack;
        data["currentDealWorkflowStatusId"] = this.currentDealWorkflowStatusId;
        data["currentDealWorkflowStatusName"] = this.currentDealWorkflowStatusName;
        data["previousWorkflowStatusId"] = this.previousWorkflowStatusId;
        data["previousDealWorkflowStatusName"] = this.previousDealWorkflowStatusName;
        data["precedingWorkflowActionName"] = this.precedingWorkflowActionName;
        data["currentWorkflowRoleName"] = this.currentWorkflowRoleName;
        return data; 
    }

    clone(): DealAssignRevertBackInfoResponse {
        const json = this.toJSON();
        let result = new DealAssignRevertBackInfoResponse();
        result.init(json);
        return result;
    }
}

export interface IDealAssignRevertBackInfoResponse {
    canRevertStatusBack: boolean;
    currentDealWorkflowStatusId: number;
    currentDealWorkflowStatusName: string;
    previousWorkflowStatusId: number;
    previousDealWorkflowStatusName: string;
    precedingWorkflowActionName: string;
    currentWorkflowRoleName: string;
}

export class DealExecutionInfoResponse implements IDealExecutionInfoResponse {
    assignedToSelf!: boolean;
    assignedToUserName!: string;
    assignedToUserId?: number | undefined;
    executed!: boolean;
    executionDate?: moment.Moment | undefined;

    constructor(data?: IDealExecutionInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            assignedToSelf: observable,
            assignedToUserName: observable,
            assignedToUserId: observable,
            executed: observable,
            executionDate: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.assignedToSelf = _data["assignedToSelf"];
            this.assignedToUserName = _data["assignedToUserName"];
            this.assignedToUserId = _data["assignedToUserId"];
            this.executed = _data["executed"];
            this.executionDate = _data["executionDate"] ? moment.parseZone(_data["executionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DealExecutionInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DealExecutionInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assignedToSelf"] = this.assignedToSelf;
        data["assignedToUserName"] = this.assignedToUserName;
        data["assignedToUserId"] = this.assignedToUserId;
        data["executed"] = this.executed;
        data["executionDate"] = this.executionDate ? this.executionDate.toISOString(true) : <any>undefined;
        return data; 
    }

    clone(): DealExecutionInfoResponse {
        const json = this.toJSON();
        let result = new DealExecutionInfoResponse();
        result.init(json);
        return result;
    }
}

export interface IDealExecutionInfoResponse {
    assignedToSelf: boolean;
    assignedToUserName: string;
    assignedToUserId?: number | undefined;
    executed: boolean;
    executionDate?: moment.Moment | undefined;
}

export class LookupRequestHeader implements ILookupRequestHeader {
    currentUser?: boolean | undefined;
    id?: number | undefined;
    name!: string;
    totalCount?: number | undefined;
    currentPage?: number | undefined;
    results!: LookupRequest[];

    constructor(data?: ILookupRequestHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new LookupRequest(item) : <LookupRequest>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
        makeObservable(this, {
            currentUser: observable,
            id: observable,
            name: observable,
            totalCount: observable,
            currentPage: observable,
            results: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.currentUser = _data["currentUser"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.totalCount = _data["totalCount"];
            this.currentPage = _data["currentPage"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(LookupRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LookupRequestHeader {
        data = typeof data === 'object' ? data : {};
        let result = new LookupRequestHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentUser"] = this.currentUser;
        data["id"] = this.id;
        data["name"] = this.name;
        data["totalCount"] = this.totalCount;
        data["currentPage"] = this.currentPage;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }

    clone(): LookupRequestHeader {
        const json = this.toJSON();
        let result = new LookupRequestHeader();
        result.init(json);
        return result;
    }
}

export interface ILookupRequestHeader {
    currentUser?: boolean | undefined;
    id?: number | undefined;
    name: string;
    totalCount?: number | undefined;
    currentPage?: number | undefined;
    results: ILookupRequest[];
}

export class DealTypeConfigurationResponse implements IDealTypeConfigurationResponse {
    dealItemFieldsetId?: number | undefined;
    dealItemFields!: DealItemFieldReadDto[];
    position!: PositionEnum;
    forcePosition!: boolean;
    unitOfMeasure!: string;
    hasLossFactors!: boolean;
    hasExpiryDate!: boolean;
    hasDelegatedAuthority!: boolean;
    workflowSetId?: number | undefined;
    currentWorkflowStatusConfig!: WorkflowStatusReadDto;
    itemExecutionImportTemplateType?: DealItemExecutionImportTemplateTypeEnum | undefined;
    noteReminderTypeLookups!: LookupRequest[];

    constructor(data?: IDealTypeConfigurationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.dealItemFields) {
                this.dealItemFields = [];
                for (let i = 0; i < data.dealItemFields.length; i++) {
                    let item = data.dealItemFields[i];
                    this.dealItemFields[i] = item && !(<any>item).toJSON ? new DealItemFieldReadDto(item) : <DealItemFieldReadDto>item;
                }
            }
            this.currentWorkflowStatusConfig = data.currentWorkflowStatusConfig && !(<any>data.currentWorkflowStatusConfig).toJSON ? new WorkflowStatusReadDto(data.currentWorkflowStatusConfig) : <WorkflowStatusReadDto>this.currentWorkflowStatusConfig; 
            if (data.noteReminderTypeLookups) {
                this.noteReminderTypeLookups = [];
                for (let i = 0; i < data.noteReminderTypeLookups.length; i++) {
                    let item = data.noteReminderTypeLookups[i];
                    this.noteReminderTypeLookups[i] = item && !(<any>item).toJSON ? new LookupRequest(item) : <LookupRequest>item;
                }
            }
        }
        if (!data) {
            this.dealItemFields = [];
            this.currentWorkflowStatusConfig = new WorkflowStatusReadDto();
            this.noteReminderTypeLookups = [];
        }
        makeObservable(this, {
            dealItemFieldsetId: observable,
            dealItemFields: observable,
            position: observable,
            forcePosition: observable,
            unitOfMeasure: observable,
            hasLossFactors: observable,
            hasExpiryDate: observable,
            hasDelegatedAuthority: observable,
            workflowSetId: observable,
            currentWorkflowStatusConfig: observable,
            itemExecutionImportTemplateType: observable,
            noteReminderTypeLookups: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.dealItemFieldsetId = _data["dealItemFieldsetId"];
            if (Array.isArray(_data["dealItemFields"])) {
                this.dealItemFields = [] as any;
                for (let item of _data["dealItemFields"])
                    this.dealItemFields!.push(DealItemFieldReadDto.fromJS(item));
            }
            this.position = _data["position"];
            this.forcePosition = _data["forcePosition"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.hasLossFactors = _data["hasLossFactors"];
            this.hasExpiryDate = _data["hasExpiryDate"];
            this.hasDelegatedAuthority = _data["hasDelegatedAuthority"];
            this.workflowSetId = _data["workflowSetId"];
            this.currentWorkflowStatusConfig = _data["currentWorkflowStatusConfig"] ? WorkflowStatusReadDto.fromJS(_data["currentWorkflowStatusConfig"]) : new WorkflowStatusReadDto();
            this.itemExecutionImportTemplateType = _data["itemExecutionImportTemplateType"];
            if (Array.isArray(_data["noteReminderTypeLookups"])) {
                this.noteReminderTypeLookups = [] as any;
                for (let item of _data["noteReminderTypeLookups"])
                    this.noteReminderTypeLookups!.push(LookupRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DealTypeConfigurationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DealTypeConfigurationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dealItemFieldsetId"] = this.dealItemFieldsetId;
        if (Array.isArray(this.dealItemFields)) {
            data["dealItemFields"] = [];
            for (let item of this.dealItemFields)
                data["dealItemFields"].push(item.toJSON());
        }
        data["position"] = this.position;
        data["forcePosition"] = this.forcePosition;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["hasLossFactors"] = this.hasLossFactors;
        data["hasExpiryDate"] = this.hasExpiryDate;
        data["hasDelegatedAuthority"] = this.hasDelegatedAuthority;
        data["workflowSetId"] = this.workflowSetId;
        data["currentWorkflowStatusConfig"] = this.currentWorkflowStatusConfig ? this.currentWorkflowStatusConfig.toJSON() : <any>undefined;
        data["itemExecutionImportTemplateType"] = this.itemExecutionImportTemplateType;
        if (Array.isArray(this.noteReminderTypeLookups)) {
            data["noteReminderTypeLookups"] = [];
            for (let item of this.noteReminderTypeLookups)
                data["noteReminderTypeLookups"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DealTypeConfigurationResponse {
        const json = this.toJSON();
        let result = new DealTypeConfigurationResponse();
        result.init(json);
        return result;
    }
}

export interface IDealTypeConfigurationResponse {
    dealItemFieldsetId?: number | undefined;
    dealItemFields: IDealItemFieldReadDto[];
    position: PositionEnum;
    forcePosition: boolean;
    unitOfMeasure: string;
    hasLossFactors: boolean;
    hasExpiryDate: boolean;
    hasDelegatedAuthority: boolean;
    workflowSetId?: number | undefined;
    currentWorkflowStatusConfig: IWorkflowStatusReadDto;
    itemExecutionImportTemplateType?: DealItemExecutionImportTemplateTypeEnum | undefined;
    noteReminderTypeLookups: ILookupRequest[];
}

export class DealItemFieldReadDto implements IDealItemFieldReadDto {
    id?: number | undefined;
    dealItemFieldsetId?: number | undefined;
    displayOrder!: number;
    field!: string;
    name!: string;
    execution!: boolean;

    constructor(data?: IDealItemFieldReadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            id: observable,
            dealItemFieldsetId: observable,
            displayOrder: observable,
            field: observable,
            name: observable,
            execution: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dealItemFieldsetId = _data["dealItemFieldsetId"];
            this.displayOrder = _data["displayOrder"];
            this.field = _data["field"];
            this.name = _data["name"];
            this.execution = _data["execution"];
        }
    }

    static fromJS(data: any): DealItemFieldReadDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealItemFieldReadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dealItemFieldsetId"] = this.dealItemFieldsetId;
        data["displayOrder"] = this.displayOrder;
        data["field"] = this.field;
        data["name"] = this.name;
        data["execution"] = this.execution;
        return data; 
    }

    clone(): DealItemFieldReadDto {
        const json = this.toJSON();
        let result = new DealItemFieldReadDto();
        result.init(json);
        return result;
    }
}

export interface IDealItemFieldReadDto {
    id?: number | undefined;
    dealItemFieldsetId?: number | undefined;
    displayOrder: number;
    field: string;
    name: string;
    execution: boolean;
}

export class WorkflowStatusReadDto implements IWorkflowStatusReadDto {
    id!: number;
    name!: string;
    allowsDealEditing!: boolean;
    allowsEditDelegatedAuthority!: boolean;
    actions!: WorkflowActionReadDto[];
    finalizeDeal!: boolean;

    constructor(data?: IWorkflowStatusReadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.actions) {
                this.actions = [];
                for (let i = 0; i < data.actions.length; i++) {
                    let item = data.actions[i];
                    this.actions[i] = item && !(<any>item).toJSON ? new WorkflowActionReadDto(item) : <WorkflowActionReadDto>item;
                }
            }
        }
        if (!data) {
            this.actions = [];
        }
        makeObservable(this, {
            id: observable,
            name: observable,
            allowsDealEditing: observable,
            allowsEditDelegatedAuthority: observable,
            actions: observable,
            finalizeDeal: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.allowsDealEditing = _data["allowsDealEditing"];
            this.allowsEditDelegatedAuthority = _data["allowsEditDelegatedAuthority"];
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(WorkflowActionReadDto.fromJS(item));
            }
            this.finalizeDeal = _data["finalizeDeal"];
        }
    }

    static fromJS(data: any): WorkflowStatusReadDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowStatusReadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["allowsDealEditing"] = this.allowsDealEditing;
        data["allowsEditDelegatedAuthority"] = this.allowsEditDelegatedAuthority;
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item.toJSON());
        }
        data["finalizeDeal"] = this.finalizeDeal;
        return data; 
    }

    clone(): WorkflowStatusReadDto {
        const json = this.toJSON();
        let result = new WorkflowStatusReadDto();
        result.init(json);
        return result;
    }
}

export interface IWorkflowStatusReadDto {
    id: number;
    name: string;
    allowsDealEditing: boolean;
    allowsEditDelegatedAuthority: boolean;
    actions: IWorkflowActionReadDto[];
    finalizeDeal: boolean;
}

export class WorkflowActionReadDto implements IWorkflowActionReadDto {
    id!: number;
    name!: string;
    description!: string;
    targetWorkflowStatus!: WorkflowStatusReadDto;
    isSubmission!: boolean;

    constructor(data?: IWorkflowActionReadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.targetWorkflowStatus = data.targetWorkflowStatus && !(<any>data.targetWorkflowStatus).toJSON ? new WorkflowStatusReadDto(data.targetWorkflowStatus) : <WorkflowStatusReadDto>this.targetWorkflowStatus; 
        }
        if (!data) {
            this.targetWorkflowStatus = new WorkflowStatusReadDto();
        }
        makeObservable(this, {
            id: observable,
            name: observable,
            description: observable,
            targetWorkflowStatus: observable,
            isSubmission: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.targetWorkflowStatus = _data["targetWorkflowStatus"] ? WorkflowStatusReadDto.fromJS(_data["targetWorkflowStatus"]) : new WorkflowStatusReadDto();
            this.isSubmission = _data["isSubmission"];
        }
    }

    static fromJS(data: any): WorkflowActionReadDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowActionReadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["targetWorkflowStatus"] = this.targetWorkflowStatus ? this.targetWorkflowStatus.toJSON() : <any>undefined;
        data["isSubmission"] = this.isSubmission;
        return data; 
    }

    clone(): WorkflowActionReadDto {
        const json = this.toJSON();
        let result = new WorkflowActionReadDto();
        result.init(json);
        return result;
    }
}

export interface IWorkflowActionReadDto {
    id: number;
    name: string;
    description: string;
    targetWorkflowStatus: IWorkflowStatusReadDto;
    isSubmission: boolean;
}

export enum DealItemExecutionImportTemplateTypeEnum {
    InternalSales = 1,
    FTRs = 2,
}

export class AttachmentTypeLookupRequest extends LookupRequest implements IAttachmentTypeLookupRequest {
    other!: boolean;

    constructor(data?: IAttachmentTypeLookupRequest) {
        super(data);
        makeObservable(this, {
            other: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.other = _data["other"];
        }
    }

    static fromJS(data: any): AttachmentTypeLookupRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentTypeLookupRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["other"] = this.other;
        super.toJSON(data);
        return data; 
    }

    clone(): AttachmentTypeLookupRequest {
        const json = this.toJSON();
        let result = new AttachmentTypeLookupRequest();
        result.init(json);
        return result;
    }
}

export interface IAttachmentTypeLookupRequest extends ILookupRequest {
    other: boolean;
}

export class EmsFetchRequest implements IEmsFetchRequest {
    startCreationDateTime!: moment.Moment;
    endCreationDateTime!: moment.Moment;

    constructor(data?: IEmsFetchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            startCreationDateTime: observable,
            endCreationDateTime: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.startCreationDateTime = _data["startCreationDateTime"] ? moment.parseZone(_data["startCreationDateTime"].toString()) : <any>undefined;
            this.endCreationDateTime = _data["endCreationDateTime"] ? moment.parseZone(_data["endCreationDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EmsFetchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EmsFetchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startCreationDateTime"] = this.startCreationDateTime ? this.startCreationDateTime.toISOString(true) : <any>undefined;
        data["endCreationDateTime"] = this.endCreationDateTime ? this.endCreationDateTime.toISOString(true) : <any>undefined;
        return data; 
    }

    clone(): EmsFetchRequest {
        const json = this.toJSON();
        let result = new EmsFetchRequest();
        result.init(json);
        return result;
    }
}

export interface IEmsFetchRequest {
    startCreationDateTime: moment.Moment;
    endCreationDateTime: moment.Moment;
}

export class DealItemFieldsetsListResponse extends ListResponse implements IDealItemFieldsetsListResponse {
    itemFieldsets!: DealItemFieldsetListDto[];

    constructor(data?: IDealItemFieldsetsListResponse) {
        super(data);
        if (data) {
            if (data.itemFieldsets) {
                this.itemFieldsets = [];
                for (let i = 0; i < data.itemFieldsets.length; i++) {
                    let item = data.itemFieldsets[i];
                    this.itemFieldsets[i] = item && !(<any>item).toJSON ? new DealItemFieldsetListDto(item) : <DealItemFieldsetListDto>item;
                }
            }
        }
        if (!data) {
            this.itemFieldsets = [];
        }
        makeObservable(this, {
            itemFieldsets: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["itemFieldsets"])) {
                this.itemFieldsets = [] as any;
                for (let item of _data["itemFieldsets"])
                    this.itemFieldsets!.push(DealItemFieldsetListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DealItemFieldsetsListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DealItemFieldsetsListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.itemFieldsets)) {
            data["itemFieldsets"] = [];
            for (let item of this.itemFieldsets)
                data["itemFieldsets"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): DealItemFieldsetsListResponse {
        const json = this.toJSON();
        let result = new DealItemFieldsetsListResponse();
        result.init(json);
        return result;
    }
}

export interface IDealItemFieldsetsListResponse extends IListResponse {
    itemFieldsets: IDealItemFieldsetListDto[];
}

export class DealItemFieldsetListDto implements IDealItemFieldsetListDto {
    id!: number;
    name!: string;
    description!: string;

    constructor(data?: IDealItemFieldsetListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            id: observable,
            name: observable,
            description: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): DealItemFieldsetListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealItemFieldsetListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }

    clone(): DealItemFieldsetListDto {
        const json = this.toJSON();
        let result = new DealItemFieldsetListDto();
        result.init(json);
        return result;
    }
}

export interface IDealItemFieldsetListDto {
    id: number;
    name: string;
    description: string;
}

export class DealItemFieldsetsListRequest extends ListRequest implements IDealItemFieldsetsListRequest {

    constructor(data?: IDealItemFieldsetsListRequest) {
        super(data);
        makeObservable(this, {
        })
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): DealItemFieldsetsListRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DealItemFieldsetsListRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }

    clone(): DealItemFieldsetsListRequest {
        const json = this.toJSON();
        let result = new DealItemFieldsetsListRequest();
        result.init(json);
        return result;
    }
}

export interface IDealItemFieldsetsListRequest extends IListRequest {
}

export class DealItemFieldsetDto extends UpdatableListItemDto implements IDealItemFieldsetDto {
    name!: UpdatableOfString;
    description!: UpdatableOfString;
    fields!: DealItemFieldDto[];

    constructor(data?: IDealItemFieldsetDto) {
        super(data);
        if (data) {
            this.name = data.name && !(<any>data.name).toJSON ? new UpdatableOfString(data.name) : <UpdatableOfString>this.name; 
            this.description = data.description && !(<any>data.description).toJSON ? new UpdatableOfString(data.description) : <UpdatableOfString>this.description; 
        }
        if (!data) {
            this.name = new UpdatableOfString();
            this.description = new UpdatableOfString();
            this.fields = [];
        }
        makeObservable(this, {
            name: observable,
            description: observable,
            fields: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"] ? UpdatableOfString.fromJS(_data["name"]) : new UpdatableOfString();
            this.description = _data["description"] ? UpdatableOfString.fromJS(_data["description"]) : new UpdatableOfString();
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(DealItemFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DealItemFieldsetDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealItemFieldsetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["description"] = this.description ? this.description.toJSON() : <any>undefined;
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): DealItemFieldsetDto {
        const json = this.toJSON();
        let result = new DealItemFieldsetDto();
        result.init(json);
        return result;
    }
}

export interface IDealItemFieldsetDto extends IUpdatableListItemDto {
    name: IUpdatableOfString;
    description: IUpdatableOfString;
    fields: DealItemFieldDto[];
}

export class DealItemFieldDto extends UpdatableListItemDto implements IDealItemFieldDto {
    displayOrder!: UpdatableOfInteger;
    name!: UpdatableOfString;
    field!: UpdatableOfString;
    execution!: UpdatableOfBoolean;

    constructor(data?: IDealItemFieldDto) {
        super(data);
        if (data) {
            this.displayOrder = data.displayOrder && !(<any>data.displayOrder).toJSON ? new UpdatableOfInteger(data.displayOrder) : <UpdatableOfInteger>this.displayOrder; 
            this.name = data.name && !(<any>data.name).toJSON ? new UpdatableOfString(data.name) : <UpdatableOfString>this.name; 
            this.field = data.field && !(<any>data.field).toJSON ? new UpdatableOfString(data.field) : <UpdatableOfString>this.field; 
            this.execution = data.execution && !(<any>data.execution).toJSON ? new UpdatableOfBoolean(data.execution) : <UpdatableOfBoolean>this.execution; 
        }
        if (!data) {
            this.displayOrder = new UpdatableOfInteger();
            this.name = new UpdatableOfString();
            this.field = new UpdatableOfString();
            this.execution = new UpdatableOfBoolean();
        }
        makeObservable(this, {
            displayOrder: observable,
            name: observable,
            field: observable,
            execution: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.displayOrder = _data["displayOrder"] ? UpdatableOfInteger.fromJS(_data["displayOrder"]) : new UpdatableOfInteger();
            this.name = _data["name"] ? UpdatableOfString.fromJS(_data["name"]) : new UpdatableOfString();
            this.field = _data["field"] ? UpdatableOfString.fromJS(_data["field"]) : new UpdatableOfString();
            this.execution = _data["execution"] ? UpdatableOfBoolean.fromJS(_data["execution"]) : new UpdatableOfBoolean();
        }
    }

    static fromJS(data: any): DealItemFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealItemFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayOrder"] = this.displayOrder ? this.displayOrder.toJSON() : <any>undefined;
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["field"] = this.field ? this.field.toJSON() : <any>undefined;
        data["execution"] = this.execution ? this.execution.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }

    clone(): DealItemFieldDto {
        const json = this.toJSON();
        let result = new DealItemFieldDto();
        result.init(json);
        return result;
    }
}

export interface IDealItemFieldDto extends IUpdatableListItemDto {
    displayOrder: IUpdatableOfInteger;
    name: IUpdatableOfString;
    field: IUpdatableOfString;
    execution: IUpdatableOfBoolean;
}

export class UpdatableOfInteger implements IUpdatableOfInteger {
    updated!: boolean;
    value!: number;

    constructor(data?: IUpdatableOfInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            updated: observable,
            value: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.updated = _data["updated"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdatableOfInteger {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatableOfInteger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["updated"] = this.updated;
        data["value"] = this.value;
        return data; 
    }

    clone(): UpdatableOfInteger {
        const json = this.toJSON();
        let result = new UpdatableOfInteger();
        result.init(json);
        return result;
    }
}

export interface IUpdatableOfInteger {
    updated: boolean;
    value: number;
}

export class StringLookupRequest implements IStringLookupRequest {
    id!: string;
    name!: string;
    description!: string;

    constructor(data?: IStringLookupRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            id: observable,
            name: observable,
            description: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): StringLookupRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StringLookupRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }

    clone(): StringLookupRequest {
        const json = this.toJSON();
        let result = new StringLookupRequest();
        result.init(json);
        return result;
    }
}

export interface IStringLookupRequest {
    id: string;
    name: string;
    description: string;
}

export class DealItemFieldsetPostResponse implements IDealItemFieldsetPostResponse {
    dealItemFieldsetName!: string;

    constructor(data?: IDealItemFieldsetPostResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            dealItemFieldsetName: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.dealItemFieldsetName = _data["dealItemFieldsetName"];
        }
    }

    static fromJS(data: any): DealItemFieldsetPostResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DealItemFieldsetPostResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dealItemFieldsetName"] = this.dealItemFieldsetName;
        return data; 
    }

    clone(): DealItemFieldsetPostResponse {
        const json = this.toJSON();
        let result = new DealItemFieldsetPostResponse();
        result.init(json);
        return result;
    }
}

export interface IDealItemFieldsetPostResponse {
    dealItemFieldsetName: string;
}

export class DealTypesListResponse extends ListResponse implements IDealTypesListResponse {
    dealTypes!: DealTypeListDto[];

    constructor(data?: IDealTypesListResponse) {
        super(data);
        if (data) {
            if (data.dealTypes) {
                this.dealTypes = [];
                for (let i = 0; i < data.dealTypes.length; i++) {
                    let item = data.dealTypes[i];
                    this.dealTypes[i] = item && !(<any>item).toJSON ? new DealTypeListDto(item) : <DealTypeListDto>item;
                }
            }
        }
        if (!data) {
            this.dealTypes = [];
        }
        makeObservable(this, {
            dealTypes: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["dealTypes"])) {
                this.dealTypes = [] as any;
                for (let item of _data["dealTypes"])
                    this.dealTypes!.push(DealTypeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DealTypesListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DealTypesListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dealTypes)) {
            data["dealTypes"] = [];
            for (let item of this.dealTypes)
                data["dealTypes"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): DealTypesListResponse {
        const json = this.toJSON();
        let result = new DealTypesListResponse();
        result.init(json);
        return result;
    }
}

export interface IDealTypesListResponse extends IListResponse {
    dealTypes: IDealTypeListDto[];
}

export class DealTypeListDto implements IDealTypeListDto {
    id!: number;
    name!: string;
    positionName!: string;
    unitOfMeasure!: string;
    hasLossFactors!: string;
    hasExpiryDate!: string;
    dealItemFieldsetName!: string;
    workflowSetName!: string;
    activeDescription!: string;

    constructor(data?: IDealTypeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            id: observable,
            name: observable,
            positionName: observable,
            unitOfMeasure: observable,
            hasLossFactors: observable,
            hasExpiryDate: observable,
            dealItemFieldsetName: observable,
            workflowSetName: observable,
            activeDescription: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.positionName = _data["positionName"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.hasLossFactors = _data["hasLossFactors"];
            this.hasExpiryDate = _data["hasExpiryDate"];
            this.dealItemFieldsetName = _data["dealItemFieldsetName"];
            this.workflowSetName = _data["workflowSetName"];
            this.activeDescription = _data["activeDescription"];
        }
    }

    static fromJS(data: any): DealTypeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealTypeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["positionName"] = this.positionName;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["hasLossFactors"] = this.hasLossFactors;
        data["hasExpiryDate"] = this.hasExpiryDate;
        data["dealItemFieldsetName"] = this.dealItemFieldsetName;
        data["workflowSetName"] = this.workflowSetName;
        data["activeDescription"] = this.activeDescription;
        return data; 
    }

    clone(): DealTypeListDto {
        const json = this.toJSON();
        let result = new DealTypeListDto();
        result.init(json);
        return result;
    }
}

export interface IDealTypeListDto {
    id: number;
    name: string;
    positionName: string;
    unitOfMeasure: string;
    hasLossFactors: string;
    hasExpiryDate: string;
    dealItemFieldsetName: string;
    workflowSetName: string;
    activeDescription: string;
}

export class DealTypesListRequest extends ListRequest implements IDealTypesListRequest {

    constructor(data?: IDealTypesListRequest) {
        super(data);
        makeObservable(this, {
        })
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): DealTypesListRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DealTypesListRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }

    clone(): DealTypesListRequest {
        const json = this.toJSON();
        let result = new DealTypesListRequest();
        result.init(json);
        return result;
    }
}

export interface IDealTypesListRequest extends IListRequest {
}

export class DealTypeDto extends UpdatableListItemDto implements IDealTypeDto {
    name!: UpdatableOfString;
    position!: UpdatableOfPositionEnum;
    forcePosition!: UpdatableOfBoolean;
    unitOfMeasure!: UpdatableOfString;
    hasLossFactors!: UpdatableOfBoolean;
    hasExpiryDate!: UpdatableOfBoolean;
    hasDelegatedAuthority!: UpdatableOfBoolean;
    dealItemFieldsetId!: UpdatableOfNullableInteger;
    workflowSetId!: UpdatableOfNullableInteger;
    active!: UpdatableOfBoolean;
    dealCategories!: number[];

    constructor(data?: IDealTypeDto) {
        super(data);
        if (data) {
            this.name = data.name && !(<any>data.name).toJSON ? new UpdatableOfString(data.name) : <UpdatableOfString>this.name; 
            this.position = data.position && !(<any>data.position).toJSON ? new UpdatableOfPositionEnum(data.position) : <UpdatableOfPositionEnum>this.position; 
            this.forcePosition = data.forcePosition && !(<any>data.forcePosition).toJSON ? new UpdatableOfBoolean(data.forcePosition) : <UpdatableOfBoolean>this.forcePosition; 
            this.unitOfMeasure = data.unitOfMeasure && !(<any>data.unitOfMeasure).toJSON ? new UpdatableOfString(data.unitOfMeasure) : <UpdatableOfString>this.unitOfMeasure; 
            this.hasLossFactors = data.hasLossFactors && !(<any>data.hasLossFactors).toJSON ? new UpdatableOfBoolean(data.hasLossFactors) : <UpdatableOfBoolean>this.hasLossFactors; 
            this.hasExpiryDate = data.hasExpiryDate && !(<any>data.hasExpiryDate).toJSON ? new UpdatableOfBoolean(data.hasExpiryDate) : <UpdatableOfBoolean>this.hasExpiryDate; 
            this.hasDelegatedAuthority = data.hasDelegatedAuthority && !(<any>data.hasDelegatedAuthority).toJSON ? new UpdatableOfBoolean(data.hasDelegatedAuthority) : <UpdatableOfBoolean>this.hasDelegatedAuthority; 
            this.dealItemFieldsetId = data.dealItemFieldsetId && !(<any>data.dealItemFieldsetId).toJSON ? new UpdatableOfNullableInteger(data.dealItemFieldsetId) : <UpdatableOfNullableInteger>this.dealItemFieldsetId; 
            this.workflowSetId = data.workflowSetId && !(<any>data.workflowSetId).toJSON ? new UpdatableOfNullableInteger(data.workflowSetId) : <UpdatableOfNullableInteger>this.workflowSetId; 
            this.active = data.active && !(<any>data.active).toJSON ? new UpdatableOfBoolean(data.active) : <UpdatableOfBoolean>this.active; 
        }
        if (!data) {
            this.name = new UpdatableOfString();
            this.position = new UpdatableOfPositionEnum();
            this.forcePosition = new UpdatableOfBoolean();
            this.unitOfMeasure = new UpdatableOfString();
            this.hasLossFactors = new UpdatableOfBoolean();
            this.hasExpiryDate = new UpdatableOfBoolean();
            this.hasDelegatedAuthority = new UpdatableOfBoolean();
            this.dealItemFieldsetId = new UpdatableOfNullableInteger();
            this.workflowSetId = new UpdatableOfNullableInteger();
            this.active = new UpdatableOfBoolean();
            this.dealCategories = [];
        }
        makeObservable(this, {
            name: observable,
            position: observable,
            forcePosition: observable,
            unitOfMeasure: observable,
            hasLossFactors: observable,
            hasExpiryDate: observable,
            hasDelegatedAuthority: observable,
            dealItemFieldsetId: observable,
            workflowSetId: observable,
            active: observable,
            dealCategories: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"] ? UpdatableOfString.fromJS(_data["name"]) : new UpdatableOfString();
            this.position = _data["position"] ? UpdatableOfPositionEnum.fromJS(_data["position"]) : new UpdatableOfPositionEnum();
            this.forcePosition = _data["forcePosition"] ? UpdatableOfBoolean.fromJS(_data["forcePosition"]) : new UpdatableOfBoolean();
            this.unitOfMeasure = _data["unitOfMeasure"] ? UpdatableOfString.fromJS(_data["unitOfMeasure"]) : new UpdatableOfString();
            this.hasLossFactors = _data["hasLossFactors"] ? UpdatableOfBoolean.fromJS(_data["hasLossFactors"]) : new UpdatableOfBoolean();
            this.hasExpiryDate = _data["hasExpiryDate"] ? UpdatableOfBoolean.fromJS(_data["hasExpiryDate"]) : new UpdatableOfBoolean();
            this.hasDelegatedAuthority = _data["hasDelegatedAuthority"] ? UpdatableOfBoolean.fromJS(_data["hasDelegatedAuthority"]) : new UpdatableOfBoolean();
            this.dealItemFieldsetId = _data["dealItemFieldsetId"] ? UpdatableOfNullableInteger.fromJS(_data["dealItemFieldsetId"]) : new UpdatableOfNullableInteger();
            this.workflowSetId = _data["workflowSetId"] ? UpdatableOfNullableInteger.fromJS(_data["workflowSetId"]) : new UpdatableOfNullableInteger();
            this.active = _data["active"] ? UpdatableOfBoolean.fromJS(_data["active"]) : new UpdatableOfBoolean();
            if (Array.isArray(_data["dealCategories"])) {
                this.dealCategories = [] as any;
                for (let item of _data["dealCategories"])
                    this.dealCategories!.push(item);
            }
        }
    }

    static fromJS(data: any): DealTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new DealTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["forcePosition"] = this.forcePosition ? this.forcePosition.toJSON() : <any>undefined;
        data["unitOfMeasure"] = this.unitOfMeasure ? this.unitOfMeasure.toJSON() : <any>undefined;
        data["hasLossFactors"] = this.hasLossFactors ? this.hasLossFactors.toJSON() : <any>undefined;
        data["hasExpiryDate"] = this.hasExpiryDate ? this.hasExpiryDate.toJSON() : <any>undefined;
        data["hasDelegatedAuthority"] = this.hasDelegatedAuthority ? this.hasDelegatedAuthority.toJSON() : <any>undefined;
        data["dealItemFieldsetId"] = this.dealItemFieldsetId ? this.dealItemFieldsetId.toJSON() : <any>undefined;
        data["workflowSetId"] = this.workflowSetId ? this.workflowSetId.toJSON() : <any>undefined;
        data["active"] = this.active ? this.active.toJSON() : <any>undefined;
        if (Array.isArray(this.dealCategories)) {
            data["dealCategories"] = [];
            for (let item of this.dealCategories)
                data["dealCategories"].push(item);
        }
        super.toJSON(data);
        return data; 
    }

    clone(): DealTypeDto {
        const json = this.toJSON();
        let result = new DealTypeDto();
        result.init(json);
        return result;
    }
}

export interface IDealTypeDto extends IUpdatableListItemDto {
    name: IUpdatableOfString;
    position: IUpdatableOfPositionEnum;
    forcePosition: IUpdatableOfBoolean;
    unitOfMeasure: IUpdatableOfString;
    hasLossFactors: IUpdatableOfBoolean;
    hasExpiryDate: IUpdatableOfBoolean;
    hasDelegatedAuthority: IUpdatableOfBoolean;
    dealItemFieldsetId: IUpdatableOfNullableInteger;
    workflowSetId: IUpdatableOfNullableInteger;
    active: IUpdatableOfBoolean;
    dealCategories: number[];
}

export class UpdatableOfPositionEnum implements IUpdatableOfPositionEnum {
    updated!: boolean;
    value!: PositionEnum;

    constructor(data?: IUpdatableOfPositionEnum) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            updated: observable,
            value: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.updated = _data["updated"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdatableOfPositionEnum {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatableOfPositionEnum();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["updated"] = this.updated;
        data["value"] = this.value;
        return data; 
    }

    clone(): UpdatableOfPositionEnum {
        const json = this.toJSON();
        let result = new UpdatableOfPositionEnum();
        result.init(json);
        return result;
    }
}

export interface IUpdatableOfPositionEnum {
    updated: boolean;
    value: PositionEnum;
}

export class DealTypePostResponse implements IDealTypePostResponse {
    dealTypeName!: string;

    constructor(data?: IDealTypePostResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            dealTypeName: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.dealTypeName = _data["dealTypeName"];
        }
    }

    static fromJS(data: any): DealTypePostResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DealTypePostResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dealTypeName"] = this.dealTypeName;
        return data; 
    }

    clone(): DealTypePostResponse {
        const json = this.toJSON();
        let result = new DealTypePostResponse();
        result.init(json);
        return result;
    }
}

export interface IDealTypePostResponse {
    dealTypeName: string;
}

export class IntegrationRunsListResponse extends ListResponse implements IIntegrationRunsListResponse {
    runs!: IntegrationRunListDto[];

    constructor(data?: IIntegrationRunsListResponse) {
        super(data);
        if (data) {
            if (data.runs) {
                this.runs = [];
                for (let i = 0; i < data.runs.length; i++) {
                    let item = data.runs[i];
                    this.runs[i] = item && !(<any>item).toJSON ? new IntegrationRunListDto(item) : <IntegrationRunListDto>item;
                }
            }
        }
        if (!data) {
            this.runs = [];
        }
        makeObservable(this, {
            runs: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["runs"])) {
                this.runs = [] as any;
                for (let item of _data["runs"])
                    this.runs!.push(IntegrationRunListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IntegrationRunsListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new IntegrationRunsListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.runs)) {
            data["runs"] = [];
            for (let item of this.runs)
                data["runs"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): IntegrationRunsListResponse {
        const json = this.toJSON();
        let result = new IntegrationRunsListResponse();
        result.init(json);
        return result;
    }
}

export interface IIntegrationRunsListResponse extends IListResponse {
    runs: IIntegrationRunListDto[];
}

export class IntegrationRunListDto implements IIntegrationRunListDto {
    id!: number;
    startedBy!: string;
    started!: moment.Moment;
    ended!: moment.Moment;
    status!: IntegrationRunStatusEnum;
    payload!: string;

    constructor(data?: IIntegrationRunListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            id: observable,
            startedBy: observable,
            started: observable,
            ended: observable,
            status: observable,
            payload: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.startedBy = _data["startedBy"];
            this.started = _data["started"] ? moment.parseZone(_data["started"].toString()) : <any>undefined;
            this.ended = _data["ended"] ? moment.parseZone(_data["ended"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.payload = _data["payload"];
        }
    }

    static fromJS(data: any): IntegrationRunListDto {
        data = typeof data === 'object' ? data : {};
        let result = new IntegrationRunListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startedBy"] = this.startedBy;
        data["started"] = this.started ? this.started.toISOString(true) : <any>undefined;
        data["ended"] = this.ended ? this.ended.toISOString(true) : <any>undefined;
        data["status"] = this.status;
        data["payload"] = this.payload;
        return data; 
    }

    clone(): IntegrationRunListDto {
        const json = this.toJSON();
        let result = new IntegrationRunListDto();
        result.init(json);
        return result;
    }
}

export interface IIntegrationRunListDto {
    id: number;
    startedBy: string;
    started: moment.Moment;
    ended: moment.Moment;
    status: IntegrationRunStatusEnum;
    payload: string;
}

export enum IntegrationRunStatusEnum {
    Running = 1,
    Success = 2,
    Warning = 3,
    Error = 4,
    ErroredButReprocessed = 5,
    ErroredButNotPending = 6,
}

export class IntegrationRunsListRequest extends ListRequest implements IIntegrationRunsListRequest {
    integrationType?: IntegrationTypeEnum | undefined;
    statuses!: IntegrationRunStatusEnum[];
    integrationRunId?: number | undefined;

    constructor(data?: IIntegrationRunsListRequest) {
        super(data);
        if (!data) {
            this.statuses = [];
        }
        makeObservable(this, {
            integrationType: observable,
            statuses: observable,
            integrationRunId: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.integrationType = _data["integrationType"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(item);
            }
            this.integrationRunId = _data["integrationRunId"];
        }
    }

    static fromJS(data: any): IntegrationRunsListRequest {
        data = typeof data === 'object' ? data : {};
        let result = new IntegrationRunsListRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["integrationType"] = this.integrationType;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item);
        }
        data["integrationRunId"] = this.integrationRunId;
        super.toJSON(data);
        return data; 
    }

    clone(): IntegrationRunsListRequest {
        const json = this.toJSON();
        let result = new IntegrationRunsListRequest();
        result.init(json);
        return result;
    }
}

export interface IIntegrationRunsListRequest extends IListRequest {
    integrationType?: IntegrationTypeEnum | undefined;
    statuses: IntegrationRunStatusEnum[];
    integrationRunId?: number | undefined;
}

export enum IntegrationTypeEnum {
    EmsTradepoint = 1,
}

export class IntegrationRunEntryDto implements IIntegrationRunEntryDto {
    id!: number;
    type!: IntegrationRunEntryTypeEnum;
    message!: string;
    details!: string;
    payload!: string;
    affectedId?: number | undefined;
    functionalityOfAffectedId?: FunctionalityEnum | undefined;
    dateTime?: moment.Moment | undefined;

    constructor(data?: IIntegrationRunEntryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            id: observable,
            type: observable,
            message: observable,
            details: observable,
            payload: observable,
            affectedId: observable,
            functionalityOfAffectedId: observable,
            dateTime: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.message = _data["message"];
            this.details = _data["details"];
            this.payload = _data["payload"];
            this.affectedId = _data["affectedId"];
            this.functionalityOfAffectedId = _data["functionalityOfAffectedId"];
            this.dateTime = _data["dateTime"] ? moment.parseZone(_data["dateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): IntegrationRunEntryDto {
        data = typeof data === 'object' ? data : {};
        let result = new IntegrationRunEntryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["message"] = this.message;
        data["details"] = this.details;
        data["payload"] = this.payload;
        data["affectedId"] = this.affectedId;
        data["functionalityOfAffectedId"] = this.functionalityOfAffectedId;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString(true) : <any>undefined;
        return data; 
    }

    clone(): IntegrationRunEntryDto {
        const json = this.toJSON();
        let result = new IntegrationRunEntryDto();
        result.init(json);
        return result;
    }
}

export interface IIntegrationRunEntryDto {
    id: number;
    type: IntegrationRunEntryTypeEnum;
    message: string;
    details: string;
    payload: string;
    affectedId?: number | undefined;
    functionalityOfAffectedId?: FunctionalityEnum | undefined;
    dateTime?: moment.Moment | undefined;
}

export enum IntegrationRunEntryTypeEnum {
    Info = 1,
    Success = 2,
    Warning = 3,
    Error = 4,
}

export class ProductsListResponse extends ListResponse implements IProductsListResponse {
    products!: ProductListDto[];

    constructor(data?: IProductsListResponse) {
        super(data);
        if (data) {
            if (data.products) {
                this.products = [];
                for (let i = 0; i < data.products.length; i++) {
                    let item = data.products[i];
                    this.products[i] = item && !(<any>item).toJSON ? new ProductListDto(item) : <ProductListDto>item;
                }
            }
        }
        if (!data) {
            this.products = [];
        }
        makeObservable(this, {
            products: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductsListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductsListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): ProductsListResponse {
        const json = this.toJSON();
        let result = new ProductsListResponse();
        result.init(json);
        return result;
    }
}

export interface IProductsListResponse extends IListResponse {
    products: IProductListDto[];
}

export class ProductListDto implements IProductListDto {
    id!: number;
    name!: string;
    dealCategory!: string;
    active!: boolean;

    constructor(data?: IProductListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            id: observable,
            name: observable,
            dealCategory: observable,
            active: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.dealCategory = _data["dealCategory"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): ProductListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["dealCategory"] = this.dealCategory;
        data["active"] = this.active;
        return data; 
    }

    clone(): ProductListDto {
        const json = this.toJSON();
        let result = new ProductListDto();
        result.init(json);
        return result;
    }
}

export interface IProductListDto {
    id: number;
    name: string;
    dealCategory: string;
    active: boolean;
}

export class ProductsListRequest extends ListRequest implements IProductsListRequest {

    constructor(data?: IProductsListRequest) {
        super(data);
        makeObservable(this, {
        })
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): ProductsListRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ProductsListRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }

    clone(): ProductsListRequest {
        const json = this.toJSON();
        let result = new ProductsListRequest();
        result.init(json);
        return result;
    }
}

export interface IProductsListRequest extends IListRequest {
}

export class ProductDto extends UpdatableListItemDto implements IProductDto {
    name!: UpdatableOfString;
    active!: UpdatableOfBoolean;
    dealCategoryId!: UpdatableOfInteger;

    constructor(data?: IProductDto) {
        super(data);
        if (data) {
            this.name = data.name && !(<any>data.name).toJSON ? new UpdatableOfString(data.name) : <UpdatableOfString>this.name; 
            this.active = data.active && !(<any>data.active).toJSON ? new UpdatableOfBoolean(data.active) : <UpdatableOfBoolean>this.active; 
            this.dealCategoryId = data.dealCategoryId && !(<any>data.dealCategoryId).toJSON ? new UpdatableOfInteger(data.dealCategoryId) : <UpdatableOfInteger>this.dealCategoryId; 
        }
        if (!data) {
            this.name = new UpdatableOfString();
            this.active = new UpdatableOfBoolean();
            this.dealCategoryId = new UpdatableOfInteger();
        }
        makeObservable(this, {
            name: observable,
            active: observable,
            dealCategoryId: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"] ? UpdatableOfString.fromJS(_data["name"]) : new UpdatableOfString();
            this.active = _data["active"] ? UpdatableOfBoolean.fromJS(_data["active"]) : new UpdatableOfBoolean();
            this.dealCategoryId = _data["dealCategoryId"] ? UpdatableOfInteger.fromJS(_data["dealCategoryId"]) : new UpdatableOfInteger();
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["active"] = this.active ? this.active.toJSON() : <any>undefined;
        data["dealCategoryId"] = this.dealCategoryId ? this.dealCategoryId.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }

    clone(): ProductDto {
        const json = this.toJSON();
        let result = new ProductDto();
        result.init(json);
        return result;
    }
}

export interface IProductDto extends IUpdatableListItemDto {
    name: IUpdatableOfString;
    active: IUpdatableOfBoolean;
    dealCategoryId: IUpdatableOfInteger;
}

export class ProductPostResponse implements IProductPostResponse {
    productName!: string;

    constructor(data?: IProductPostResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            productName: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.productName = _data["productName"];
        }
    }

    static fromJS(data: any): ProductPostResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPostResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productName"] = this.productName;
        return data; 
    }

    clone(): ProductPostResponse {
        const json = this.toJSON();
        let result = new ProductPostResponse();
        result.init(json);
        return result;
    }
}

export interface IProductPostResponse {
    productName: string;
}

export class DealDirectWorkflowActionResponse implements IDealDirectWorkflowActionResponse {
    success!: boolean;
    messages!: string[];
    reasonIsRequired!: boolean;
    dealNumber!: string;

    constructor(data?: IDealDirectWorkflowActionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.messages = [];
        }
        makeObservable(this, {
            success: observable,
            messages: observable,
            reasonIsRequired: observable,
            dealNumber: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(item);
            }
            this.reasonIsRequired = _data["reasonIsRequired"];
            this.dealNumber = _data["dealNumber"];
        }
    }

    static fromJS(data: any): DealDirectWorkflowActionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DealDirectWorkflowActionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item);
        }
        data["reasonIsRequired"] = this.reasonIsRequired;
        data["dealNumber"] = this.dealNumber;
        return data; 
    }

    clone(): DealDirectWorkflowActionResponse {
        const json = this.toJSON();
        let result = new DealDirectWorkflowActionResponse();
        result.init(json);
        return result;
    }
}

export interface IDealDirectWorkflowActionResponse {
    success: boolean;
    messages: string[];
    reasonIsRequired: boolean;
    dealNumber: string;
}

export class DealDirectWorkflowActionRequest implements IDealDirectWorkflowActionRequest {
    dealId!: number;
    userId!: number;
    key!: string;
    actionId!: number;
    actionName!: string;
    reason!: string;

    constructor(data?: IDealDirectWorkflowActionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            dealId: observable,
            userId: observable,
            key: observable,
            actionId: observable,
            actionName: observable,
            reason: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.dealId = _data["dealId"];
            this.userId = _data["userId"];
            this.key = _data["key"];
            this.actionId = _data["actionId"];
            this.actionName = _data["actionName"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): DealDirectWorkflowActionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DealDirectWorkflowActionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dealId"] = this.dealId;
        data["userId"] = this.userId;
        data["key"] = this.key;
        data["actionId"] = this.actionId;
        data["actionName"] = this.actionName;
        data["reason"] = this.reason;
        return data; 
    }

    clone(): DealDirectWorkflowActionRequest {
        const json = this.toJSON();
        let result = new DealDirectWorkflowActionRequest();
        result.init(json);
        return result;
    }
}

export interface IDealDirectWorkflowActionRequest {
    dealId: number;
    userId: number;
    key: string;
    actionId: number;
    actionName: string;
    reason: string;
}

export class SalesForecastsListResponse extends ListResponse implements ISalesForecastsListResponse {
    salesForecasts!: SalesForecastListDto[];

    constructor(data?: ISalesForecastsListResponse) {
        super(data);
        if (data) {
            if (data.salesForecasts) {
                this.salesForecasts = [];
                for (let i = 0; i < data.salesForecasts.length; i++) {
                    let item = data.salesForecasts[i];
                    this.salesForecasts[i] = item && !(<any>item).toJSON ? new SalesForecastListDto(item) : <SalesForecastListDto>item;
                }
            }
        }
        if (!data) {
            this.salesForecasts = [];
        }
        makeObservable(this, {
            salesForecasts: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["salesForecasts"])) {
                this.salesForecasts = [] as any;
                for (let item of _data["salesForecasts"])
                    this.salesForecasts!.push(SalesForecastListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SalesForecastsListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SalesForecastsListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.salesForecasts)) {
            data["salesForecasts"] = [];
            for (let item of this.salesForecasts)
                data["salesForecasts"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): SalesForecastsListResponse {
        const json = this.toJSON();
        let result = new SalesForecastsListResponse();
        result.init(json);
        return result;
    }
}

export interface ISalesForecastsListResponse extends IListResponse {
    salesForecasts: ISalesForecastListDto[];
}

export class SalesForecastListDto implements ISalesForecastListDto {
    id!: number;
    monthYear!: moment.Moment;
    volume!: number;

    constructor(data?: ISalesForecastListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            id: observable,
            monthYear: observable,
            volume: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.monthYear = _data["monthYear"] ? moment.parseZone(_data["monthYear"].toString()) : <any>undefined;
            this.volume = _data["volume"];
        }
    }

    static fromJS(data: any): SalesForecastListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesForecastListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["monthYear"] = this.monthYear ? this.monthYear.toISOString(true) : <any>undefined;
        data["volume"] = this.volume;
        return data; 
    }

    clone(): SalesForecastListDto {
        const json = this.toJSON();
        let result = new SalesForecastListDto();
        result.init(json);
        return result;
    }
}

export interface ISalesForecastListDto {
    id: number;
    monthYear: moment.Moment;
    volume: number;
}

export class SalesForecastsListRequest extends ListRequest implements ISalesForecastsListRequest {

    constructor(data?: ISalesForecastsListRequest) {
        super(data);
        makeObservable(this, {
        })
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): SalesForecastsListRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SalesForecastsListRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }

    clone(): SalesForecastsListRequest {
        const json = this.toJSON();
        let result = new SalesForecastsListRequest();
        result.init(json);
        return result;
    }
}

export interface ISalesForecastsListRequest extends IListRequest {
}

export class SalesForecastDto extends UpdatableListItemDto implements ISalesForecastDto {
    monthYear!: UpdatableOfDateTimeOffset;
    volume!: UpdatableOfDecimal;

    constructor(data?: ISalesForecastDto) {
        super(data);
        if (data) {
            this.monthYear = data.monthYear && !(<any>data.monthYear).toJSON ? new UpdatableOfDateTimeOffset(data.monthYear) : <UpdatableOfDateTimeOffset>this.monthYear; 
            this.volume = data.volume && !(<any>data.volume).toJSON ? new UpdatableOfDecimal(data.volume) : <UpdatableOfDecimal>this.volume; 
        }
        if (!data) {
            this.monthYear = new UpdatableOfDateTimeOffset();
            this.volume = new UpdatableOfDecimal();
        }
        makeObservable(this, {
            monthYear: observable,
            volume: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.monthYear = _data["monthYear"] ? UpdatableOfDateTimeOffset.fromJS(_data["monthYear"]) : new UpdatableOfDateTimeOffset();
            this.volume = _data["volume"] ? UpdatableOfDecimal.fromJS(_data["volume"]) : new UpdatableOfDecimal();
        }
    }

    static fromJS(data: any): SalesForecastDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesForecastDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["monthYear"] = this.monthYear ? this.monthYear.toJSON() : <any>undefined;
        data["volume"] = this.volume ? this.volume.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }

    clone(): SalesForecastDto {
        const json = this.toJSON();
        let result = new SalesForecastDto();
        result.init(json);
        return result;
    }
}

export interface ISalesForecastDto extends IUpdatableListItemDto {
    monthYear: IUpdatableOfDateTimeOffset;
    volume: IUpdatableOfDecimal;
}

export class SalesForecastPostResponse implements ISalesForecastPostResponse {
    salesForecastName!: string;

    constructor(data?: ISalesForecastPostResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            salesForecastName: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.salesForecastName = _data["salesForecastName"];
        }
    }

    static fromJS(data: any): SalesForecastPostResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SalesForecastPostResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["salesForecastName"] = this.salesForecastName;
        return data; 
    }

    clone(): SalesForecastPostResponse {
        const json = this.toJSON();
        let result = new SalesForecastPostResponse();
        result.init(json);
        return result;
    }
}

export interface ISalesForecastPostResponse {
    salesForecastName: string;
}

export class EnumsDefinitionsRequest implements IEnumsDefinitionsRequest {
    dealCategoryEnum!: DealCategoryEnum;
    dealStatusEnum!: DealStatusEnum;

    constructor(data?: IEnumsDefinitionsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            dealCategoryEnum: observable,
            dealStatusEnum: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.dealCategoryEnum = _data["dealCategoryEnum"];
            this.dealStatusEnum = _data["dealStatusEnum"];
        }
    }

    static fromJS(data: any): EnumsDefinitionsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EnumsDefinitionsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dealCategoryEnum"] = this.dealCategoryEnum;
        data["dealStatusEnum"] = this.dealStatusEnum;
        return data; 
    }

    clone(): EnumsDefinitionsRequest {
        const json = this.toJSON();
        let result = new EnumsDefinitionsRequest();
        result.init(json);
        return result;
    }
}

export interface IEnumsDefinitionsRequest {
    dealCategoryEnum: DealCategoryEnum;
    dealStatusEnum: DealStatusEnum;
}

export enum DealCategoryEnum {
    Electricity = 1,
    Carbon = 2,
    Gas = 3,
}

export enum DealStatusEnum {
    Entered = 1,
    Updated = 2,
    Submitted = 3,
    Validated = 4,
    Approved = 5,
    Rejected = 6,
    Executed = 7,
    CheckedByMidOffice = 8,
    CheckedByBackOfficeCancelledInactive = 9,
    Copy = 10,
    CompletedInactive = 11,
}

export class UsersListResponse extends ListResponse implements IUsersListResponse {
    users!: UserListDto[];

    constructor(data?: IUsersListResponse) {
        super(data);
        if (data) {
            if (data.users) {
                this.users = [];
                for (let i = 0; i < data.users.length; i++) {
                    let item = data.users[i];
                    this.users[i] = item && !(<any>item).toJSON ? new UserListDto(item) : <UserListDto>item;
                }
            }
        }
        if (!data) {
            this.users = [];
        }
        makeObservable(this, {
            users: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UsersListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UsersListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }

    clone(): UsersListResponse {
        const json = this.toJSON();
        let result = new UsersListResponse();
        result.init(json);
        return result;
    }
}

export interface IUsersListResponse extends IListResponse {
    users: IUserListDto[];
}

export class UserListDto implements IUserListDto {
    id!: number;
    username!: string;
    name!: string;
    userRoleName!: string;
    workflowRoleNames!: string[];
    active!: boolean;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.workflowRoleNames = [];
        }
        makeObservable(this, {
            id: observable,
            username: observable,
            name: observable,
            userRoleName: observable,
            workflowRoleNames: observable,
            active: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.name = _data["name"];
            this.userRoleName = _data["userRoleName"];
            if (Array.isArray(_data["workflowRoleNames"])) {
                this.workflowRoleNames = [] as any;
                for (let item of _data["workflowRoleNames"])
                    this.workflowRoleNames!.push(item);
            }
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["name"] = this.name;
        data["userRoleName"] = this.userRoleName;
        if (Array.isArray(this.workflowRoleNames)) {
            data["workflowRoleNames"] = [];
            for (let item of this.workflowRoleNames)
                data["workflowRoleNames"].push(item);
        }
        data["active"] = this.active;
        return data; 
    }

    clone(): UserListDto {
        const json = this.toJSON();
        let result = new UserListDto();
        result.init(json);
        return result;
    }
}

export interface IUserListDto {
    id: number;
    username: string;
    name: string;
    userRoleName: string;
    workflowRoleNames: string[];
    active: boolean;
}

export class UsersListRequest extends ListRequest implements IUsersListRequest {
    onlyUsersWithLevel?: boolean | undefined;

    constructor(data?: IUsersListRequest) {
        super(data);
        makeObservable(this, {
            onlyUsersWithLevel: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.onlyUsersWithLevel = _data["onlyUsersWithLevel"];
        }
    }

    static fromJS(data: any): UsersListRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UsersListRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onlyUsersWithLevel"] = this.onlyUsersWithLevel;
        super.toJSON(data);
        return data; 
    }

    clone(): UsersListRequest {
        const json = this.toJSON();
        let result = new UsersListRequest();
        result.init(json);
        return result;
    }
}

export interface IUsersListRequest extends IListRequest {
    onlyUsersWithLevel?: boolean | undefined;
}

export class UserDto implements IUserDto {
    id?: number | undefined;
    username!: UpdatableOfString;
    name!: UpdatableOfString;
    userRoleId!: UpdatableOfNullableInteger;
    active!: UpdatableOfBoolean;
    workflowRolesInUser!: UserInWorkflowRoleDto[];
    integrationData!: UserIntegrationDataDto[];

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.username = data.username && !(<any>data.username).toJSON ? new UpdatableOfString(data.username) : <UpdatableOfString>this.username; 
            this.name = data.name && !(<any>data.name).toJSON ? new UpdatableOfString(data.name) : <UpdatableOfString>this.name; 
            this.userRoleId = data.userRoleId && !(<any>data.userRoleId).toJSON ? new UpdatableOfNullableInteger(data.userRoleId) : <UpdatableOfNullableInteger>this.userRoleId; 
            this.active = data.active && !(<any>data.active).toJSON ? new UpdatableOfBoolean(data.active) : <UpdatableOfBoolean>this.active; 
        }
        if (!data) {
            this.username = new UpdatableOfString();
            this.name = new UpdatableOfString();
            this.userRoleId = new UpdatableOfNullableInteger();
            this.active = new UpdatableOfBoolean();
            this.workflowRolesInUser = [];
            this.integrationData = [];
        }
        makeObservable(this, {
            id: observable,
            username: observable,
            name: observable,
            userRoleId: observable,
            active: observable,
            workflowRolesInUser: observable,
            integrationData: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"] ? UpdatableOfString.fromJS(_data["username"]) : new UpdatableOfString();
            this.name = _data["name"] ? UpdatableOfString.fromJS(_data["name"]) : new UpdatableOfString();
            this.userRoleId = _data["userRoleId"] ? UpdatableOfNullableInteger.fromJS(_data["userRoleId"]) : new UpdatableOfNullableInteger();
            this.active = _data["active"] ? UpdatableOfBoolean.fromJS(_data["active"]) : new UpdatableOfBoolean();
            if (Array.isArray(_data["workflowRolesInUser"])) {
                this.workflowRolesInUser = [] as any;
                for (let item of _data["workflowRolesInUser"])
                    this.workflowRolesInUser!.push(UserInWorkflowRoleDto.fromJS(item));
            }
            if (Array.isArray(_data["integrationData"])) {
                this.integrationData = [] as any;
                for (let item of _data["integrationData"])
                    this.integrationData!.push(UserIntegrationDataDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username ? this.username.toJSON() : <any>undefined;
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["userRoleId"] = this.userRoleId ? this.userRoleId.toJSON() : <any>undefined;
        data["active"] = this.active ? this.active.toJSON() : <any>undefined;
        if (Array.isArray(this.workflowRolesInUser)) {
            data["workflowRolesInUser"] = [];
            for (let item of this.workflowRolesInUser)
                data["workflowRolesInUser"].push(item.toJSON());
        }
        if (Array.isArray(this.integrationData)) {
            data["integrationData"] = [];
            for (let item of this.integrationData)
                data["integrationData"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    id?: number | undefined;
    username: IUpdatableOfString;
    name: IUpdatableOfString;
    userRoleId: IUpdatableOfNullableInteger;
    active: IUpdatableOfBoolean;
    workflowRolesInUser: UserInWorkflowRoleDto[];
    integrationData: UserIntegrationDataDto[];
}

export class UserInWorkflowRoleDto extends UpdatableListItemDto implements IUserInWorkflowRoleDto {
    userId!: UpdatableOfInteger;
    userName!: string;
    workflowRoleId!: UpdatableOfInteger;
    workflowRoleName!: string;
    active!: UpdatableOfBoolean;

    constructor(data?: IUserInWorkflowRoleDto) {
        super(data);
        if (data) {
            this.userId = data.userId && !(<any>data.userId).toJSON ? new UpdatableOfInteger(data.userId) : <UpdatableOfInteger>this.userId; 
            this.workflowRoleId = data.workflowRoleId && !(<any>data.workflowRoleId).toJSON ? new UpdatableOfInteger(data.workflowRoleId) : <UpdatableOfInteger>this.workflowRoleId; 
            this.active = data.active && !(<any>data.active).toJSON ? new UpdatableOfBoolean(data.active) : <UpdatableOfBoolean>this.active; 
        }
        if (!data) {
            this.userId = new UpdatableOfInteger();
            this.workflowRoleId = new UpdatableOfInteger();
            this.active = new UpdatableOfBoolean();
        }
        makeObservable(this, {
            userId: observable,
            userName: observable,
            workflowRoleId: observable,
            workflowRoleName: observable,
            active: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userId = _data["userId"] ? UpdatableOfInteger.fromJS(_data["userId"]) : new UpdatableOfInteger();
            this.userName = _data["userName"];
            this.workflowRoleId = _data["workflowRoleId"] ? UpdatableOfInteger.fromJS(_data["workflowRoleId"]) : new UpdatableOfInteger();
            this.workflowRoleName = _data["workflowRoleName"];
            this.active = _data["active"] ? UpdatableOfBoolean.fromJS(_data["active"]) : new UpdatableOfBoolean();
        }
    }

    static fromJS(data: any): UserInWorkflowRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInWorkflowRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId ? this.userId.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["workflowRoleId"] = this.workflowRoleId ? this.workflowRoleId.toJSON() : <any>undefined;
        data["workflowRoleName"] = this.workflowRoleName;
        data["active"] = this.active ? this.active.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }

    clone(): UserInWorkflowRoleDto {
        const json = this.toJSON();
        let result = new UserInWorkflowRoleDto();
        result.init(json);
        return result;
    }
}

export interface IUserInWorkflowRoleDto extends IUpdatableListItemDto {
    userId: IUpdatableOfInteger;
    userName: string;
    workflowRoleId: IUpdatableOfInteger;
    workflowRoleName: string;
    active: IUpdatableOfBoolean;
}

export class UserIntegrationDataDto extends UpdatableListItemDto implements IUserIntegrationDataDto {
    integrationType!: IntegrationTypeEnum;
    field!: UserIntegrationFieldEnum;
    data!: UpdatableOfString;
    active!: UpdatableOfBoolean;

    constructor(data?: IUserIntegrationDataDto) {
        super(data);
        if (data) {
            this.data = data.data && !(<any>data.data).toJSON ? new UpdatableOfString(data.data) : <UpdatableOfString>this.data; 
            this.active = data.active && !(<any>data.active).toJSON ? new UpdatableOfBoolean(data.active) : <UpdatableOfBoolean>this.active; 
        }
        if (!data) {
            this.data = new UpdatableOfString();
            this.active = new UpdatableOfBoolean();
        }
        makeObservable(this, {
            integrationType: observable,
            field: observable,
            data: observable,
            active: observable,
        })
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.integrationType = _data["integrationType"];
            this.field = _data["field"];
            this.data = _data["data"] ? UpdatableOfString.fromJS(_data["data"]) : new UpdatableOfString();
            this.active = _data["active"] ? UpdatableOfBoolean.fromJS(_data["active"]) : new UpdatableOfBoolean();
        }
    }

    static fromJS(data: any): UserIntegrationDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserIntegrationDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["integrationType"] = this.integrationType;
        data["field"] = this.field;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["active"] = this.active ? this.active.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }

    clone(): UserIntegrationDataDto {
        const json = this.toJSON();
        let result = new UserIntegrationDataDto();
        result.init(json);
        return result;
    }
}

export interface IUserIntegrationDataDto extends IUpdatableListItemDto {
    integrationType: IntegrationTypeEnum;
    field: UserIntegrationFieldEnum;
    data: IUpdatableOfString;
    active: IUpdatableOfBoolean;
}

export enum UserIntegrationFieldEnum {
    UserIdAtTheSource = 1,
}

export class UserPostResponse implements IUserPostResponse {
    name!: string;

    constructor(data?: IUserPostResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            name: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UserPostResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserPostResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): UserPostResponse {
        const json = this.toJSON();
        let result = new UserPostResponse();
        result.init(json);
        return result;
    }
}

export interface IUserPostResponse {
    name: string;
}

export class UserFunctionalityReadDto implements IUserFunctionalityReadDto {
    functionalityEnum!: FunctionalityEnum;
    subFunctionalities!: UserSubFunctionalityReadDto[];

    constructor(data?: IUserFunctionalityReadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.subFunctionalities) {
                this.subFunctionalities = [];
                for (let i = 0; i < data.subFunctionalities.length; i++) {
                    let item = data.subFunctionalities[i];
                    this.subFunctionalities[i] = item && !(<any>item).toJSON ? new UserSubFunctionalityReadDto(item) : <UserSubFunctionalityReadDto>item;
                }
            }
        }
        if (!data) {
            this.subFunctionalities = [];
        }
        makeObservable(this, {
            functionalityEnum: observable,
            subFunctionalities: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.functionalityEnum = _data["functionalityEnum"];
            if (Array.isArray(_data["subFunctionalities"])) {
                this.subFunctionalities = [] as any;
                for (let item of _data["subFunctionalities"])
                    this.subFunctionalities!.push(UserSubFunctionalityReadDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserFunctionalityReadDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserFunctionalityReadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["functionalityEnum"] = this.functionalityEnum;
        if (Array.isArray(this.subFunctionalities)) {
            data["subFunctionalities"] = [];
            for (let item of this.subFunctionalities)
                data["subFunctionalities"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserFunctionalityReadDto {
        const json = this.toJSON();
        let result = new UserFunctionalityReadDto();
        result.init(json);
        return result;
    }
}

export interface IUserFunctionalityReadDto {
    functionalityEnum: FunctionalityEnum;
    subFunctionalities: IUserSubFunctionalityReadDto[];
}

export class UserSubFunctionalityReadDto implements IUserSubFunctionalityReadDto {
    subFunctionalityEnum!: SubFunctionalityEnum;

    constructor(data?: IUserSubFunctionalityReadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        makeObservable(this, {
            subFunctionalityEnum: observable,
        })
    }

    init(_data?: any) {
        if (_data) {
            this.subFunctionalityEnum = _data["subFunctionalityEnum"];
        }
    }

    static fromJS(data: any): UserSubFunctionalityReadDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserSubFunctionalityReadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subFunctionalityEnum"] = this.subFunctionalityEnum;
        return data; 
    }

    clone(): UserSubFunctionalityReadDto {
        const json = this.toJSON();
        let result = new UserSubFunctionalityReadDto();
        result.init(json);
        return result;
    }
}

export interface IUserSubFunctionalityReadDto {
    subFunctionalityEnum: SubFunctionalityEnum;
}

export enum SubFunctionalityEnum {
    Create = 1,
    View = 2,
    Edit = 3,
    Delete = 4,
    SelectDealLossFactors = 5,
    EditDealLossFactorsValue = 6,
    PDFExport = 7,
    AuditLogsView = 8,
    ExecuteDeal = 9,
    RunIntegration = 10,
    ReprocessIntegration = 11,
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}